<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>6-Axis FPS Engine (No Mag)</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: #000; color: #0f0; }
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 4px; height: 4px;
            background: #0f0; border-radius: 50%;
            box-shadow: 0 0 10px #0f0;
            transform: translate(-50%, -50%);
        }

        #panel {
            position: absolute; top: 20px; right: 20px; width: 250px;
            background: rgba(0,0,0,0.8); border: 1px solid #333; padding: 20px;
            pointer-events: auto;
        }
        
        button {
            width: 100%; padding: 12px; margin-top: 10px; background: #222; 
            color: #fff; border: 1px solid #444; cursor: pointer; font-weight: bold;
        }
        button:hover { background: #333; border-color: #666; }
        button#btn-connect { background: #0066cc; border-color: #004488; }
        
        .stat { display: flex; justify-content: space-between; font-size: 13px; color: #aaa; margin-bottom: 4px; }
        .stat span { color: #fff; font-family: monospace; }
        
        h2 { margin: 0 0 15px 0; font-size: 16px; color: #fff; border-bottom: 1px solid #444; padding-bottom: 5px; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="viewport"></div>

    <div id="ui">
        <div id="crosshair"></div>
        <div id="panel">
            <h2>6-AXIS CONTROLLER</h2>
            <button id="btn-connect">CONNECT</button>
            <button id="btn-tare">TARE (Reset View)</button>
            
            <div style="margin-top: 20px; border-top: 1px solid #333; padding-top: 10px;">
                <div class="stat">Pitch: <span id="val-pitch">0</span>&deg;</div>
                <div class="stat">Roll: <span id="val-roll">0</span>&deg;</div>
                <div class="stat">Yaw (Drifting): <span id="val-yaw">0</span>&deg;</div>
            </div>
            <p style="font-size: 11px; color: #666; margin-top: 10px; line-height: 1.4;">
                *Using 6-Axis Fusion. Yaw will drift over time. Use TARE to re-center.
            </p>
        </div>
    </div>

    <script>
        // ==========================================
        // 1. 6-AXIS MADGWICK (IMU Only - No Mag)
        // ==========================================
        class Madgwick6Axis {
            constructor(sampleFreq, beta) {
                this.sampleFreq = sampleFreq;
                this.beta = beta;
                this.q0 = 1.0; this.q1 = 0.0; this.q2 = 0.0; this.q3 = 0.0;
            }

            update(gx, gy, gz, ax, ay, az) {
                let q0 = this.q0, q1 = this.q1, q2 = this.q2, q3 = this.q3;
                let recipNorm;
                let s0, s1, s2, s3;
                let qDot1, qDot2, qDot3, qDot4;
                let _2q0, _2q1, _2q2, _2q3, _4q0, _4q1, _4q2 ,_8q1, _8q2, q0q0, q1q1, q2q2, q3q3;

                // Rate of change of quaternion from gyroscope
                qDot1 = 0.5 * (-q1 * gx - q2 * gy - q3 * gz);
                qDot2 = 0.5 * (q0 * gx + q2 * gz - q3 * gy);
                qDot3 = 0.5 * (q0 * gy - q1 * gz + q3 * gx);
                qDot4 = 0.5 * (q0 * gz + q1 * gy - q2 * gx);

                // Compute feedback only if accelerometer measurement valid
                if(!((ax === 0.0) && (ay === 0.0) && (az === 0.0))) {
                    // Normalise accelerometer measurement
                    recipNorm = 1.0 / Math.sqrt(ax * ax + ay * ay + az * az);
                    ax *= recipNorm; ay *= recipNorm; az *= recipNorm;

                    // Auxiliary variables to avoid repeated arithmetic
                    _2q0 = 2.0 * q0;
                    _2q1 = 2.0 * q1;
                    _2q2 = 2.0 * q2;
                    _2q3 = 2.0 * q3;
                    _4q0 = 4.0 * q0;
                    _4q1 = 4.0 * q1;
                    _4q2 = 4.0 * q2;
                    _8q1 = 8.0 * q1;
                    _8q2 = 8.0 * q2;
                    q0q0 = q0 * q0;
                    q1q1 = q1 * q1;
                    q2q2 = q2 * q2;
                    q3q3 = q3 * q3;

                    // Gradient decent algorithm corrective step
                    s0 = _4q0 * q2q2 + _2q2 * ax + _4q0 * q1q1 - _2q1 * ay;
                    s1 = _4q1 * q3q3 - _2q3 * ax + 4.0 * q0q0 * q1 - _2q0 * ay - _4q1 + _8q1 * q1q1 + _8q1 * q2q2 + _4q1 * az;
                    s2 = 4.0 * q0q0 * q2 + _2q0 * ax + _4q2 * q3q3 - _2q3 * ay - _4q2 + _8q2 * q1q1 + _8q2 * q2q2 + _4q2 * az;
                    s3 = 4.0 * q1q1 * q3 - _2q1 * ax + 4.0 * q2q2 * q3 - _2q2 * ay;
                    
                    recipNorm = 1.0 / Math.sqrt(s0 * s0 + s1 * s1 + s2 * s2 + s3 * s3);
                    s0 *= recipNorm; s1 *= recipNorm; s2 *= recipNorm; s3 *= recipNorm;

                    // Apply feedback step
                    qDot1 -= this.beta * s0;
                    qDot2 -= this.beta * s1;
                    qDot3 -= this.beta * s2;
                    qDot4 -= this.beta * s3;
                }

                // Integrate rate of change
                q0 += qDot1 * (1.0 / this.sampleFreq);
                q1 += qDot2 * (1.0 / this.sampleFreq);
                q2 += qDot3 * (1.0 / this.sampleFreq);
                q3 += qDot4 * (1.0 / this.sampleFreq);

                // Normalise quaternion
                recipNorm = 1.0 / Math.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);
                this.q0 = q0 * recipNorm;
                this.q1 = q1 * recipNorm;
                this.q2 = q2 * recipNorm;
                this.q3 = q3 * recipNorm;
            }

            getQuaternion() { return [this.q0, this.q1, this.q2, this.q3]; }
        }

        // ==========================================
        // 2. MAIN LOGIC
        // ==========================================
        const filter = new Madgwick6Axis(200.0, 0.05); // 200Hz, Beta 0.05
        
        // Scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x101010);
        scene.fog = new THREE.Fog(0x101010, 0, 50);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({antialias:true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('viewport').appendChild(renderer.domElement);

        // Environment
        const grid = new THREE.GridHelper(200, 50, 0x333333, 0x111111);
        grid.position.y = -5;
        scene.add(grid);

        // Targets
        const geo = new THREE.BoxGeometry(2, 6, 2);
        const mat = new THREE.MeshBasicMaterial({color:0xff3333, wireframe:true});
        for(let i=0; i<20; i++) {
            const m = new THREE.Mesh(geo, mat);
            m.position.set((Math.random()-0.5)*80, -2, (Math.random()-0.5)*80);
            scene.add(m);
        }
        
        // Vars
        let port, reader;
        const targetQuat = new THREE.Quaternion();
        const tareQuat = new THREE.Quaternion();

        // Serial
        document.getElementById('btn-connect').onclick = async () => {
            if(!navigator.serial) return alert("Use Chrome/Edge.");
            port = await navigator.serial.requestPort();
            await port.open({baudRate: 115200});
            document.getElementById('btn-connect').style.display='none';
            readLoop();
        };

        async function readLoop() {
            const dec = new TextDecoderStream();
            port.readable.pipeTo(dec.writable);
            const r = dec.readable.getReader();
            let buf = "";
            while(true) {
                const {value, done} = await r.read();
                if(value) {
                    buf += value;
                    const lines = buf.split('\n');
                    buf = lines.pop();
                    for(let l of lines) process(l);
                }
            }
        }

        function process(line) {
            // RAW:ax,ay,az,gx,gy,gz,0,0,0
            if(!line.startsWith("RAW:")) return;
            const d = line.substring(4).split(',').map(Number);
            if(d.length < 6) return;

            // Convert Units
            let ax = d[0], ay = d[1], az = d[2];
            
            // Gyro: Convert from dps to radians/sec
            // Range 1000 dps -> 32.8 LSB/deg/s (Check datasheet for scale!)
            // Or if library returns floats in DPS:
            let gx = d[3] * (Math.PI/180);
            let gy = d[4] * (Math.PI/180);
            let gz = d[5] * (Math.PI/180);

            // Update Filter
            // Swap axes here if needed to match screen. 
            // Standard: Gyro X->X, Y->Y, Z->Z
            filter.update(gx, gy, gz, ax, ay, az);

            // Apply to Camera
            const q = filter.getQuaternion(); 
            // Map NED to ENU (Y-Up): w, x, z, -y
            const rawQ = new THREE.Quaternion(q[1], q[3], -q[2], q[0]);
            
            targetQuat.copy(tareQuat).multiply(rawQ);

            // Update UI
            const e = new THREE.Euler().setFromQuaternion(targetQuat, 'YXZ');
            document.getElementById('val-pitch').innerText = Math.round(e.x * 180/Math.PI);
            document.getElementById('val-yaw').innerText = Math.round(e.y * 180/Math.PI);
            document.getElementById('val-roll').innerText = Math.round(e.z * 180/Math.PI);
        }

        document.getElementById('btn-tare').onclick = () => {
            // Inverse current rotation to set new zero
            tareQuat.copy(targetQuat.clone().invert().multiply(tareQuat));
            // Actually, simplest tare is: Tare = Inv(Raw)
            // But doing it incrementally above allows repeated tares.
            // Let's do hard reset tare for drift:
            const currentRaw = new THREE.Quaternion().setFromEuler(new THREE.Euler(0,0,0)); 
            // Complex math omitted: simple UI reset is better for gaming
            // Just reloading page works, but let's try this:
            const q = filter.getQuaternion(); 
            const rawQ = new THREE.Quaternion(q[1], q[3], -q[2], q[0]);
            tareQuat.copy(rawQ.invert());
        };

        function animate() {
            requestAnimationFrame(animate);
            camera.quaternion.slerp(targetQuat, 0.5);
            renderer.render(scene, camera);
        }
        animate();
        
        window.onresize = () => {
            camera.aspect=window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth,window.innerHeight);
        };
    </script>
</body>
</html>