<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>IMU Aim — Revamp (3D, Smoother Aim, Prediction)</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
:root{
  --bg:#041122; --panel:#07172b; --muted:#9fb3d6; --accent:#78a1ff; --good:#86efac; --bad:#ff6b6b;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:linear-gradient(180deg,#02061a 0%,#041022 100%);color:#e7f3ff;font-family:Inter,system-ui,Roboto,Arial;}
.app{display:flex;height:100vh;padding:14px;gap:12px}
.left{width:380px;background:var(--panel);border-radius:12px;padding:16px;border:1px solid rgba(255,255,255,0.03);display:flex;flex-direction:column}
.right{flex:1;background:linear-gradient(180deg,#051024,#031024);border-radius:12px;padding:12px;border:1px solid rgba(255,255,255,0.03);display:flex;flex-direction:column}
.h1{font-size:18px;font-weight:700;margin:0}
.muted{color:var(--muted);font-size:13px}
.row{display:flex;gap:8px;align-items:center}
.btn{background:#082231;border:1px solid #12303f;color:#eaf6ff;padding:8px 10px;border-radius:8px;cursor:pointer;font-weight:700}
.small{font-size:13px;color:var(--muted)}
.control{margin-top:10px}
.canvasWrap{flex:1;display:flex;gap:12px}
#view3d{flex:1;border-radius:8px;overflow:hidden;background:transparent;border:1px solid rgba(255,255,255,0.02)}
.hud{display:flex;gap:8px;align-items:center;margin-bottom:8px}
.badge{background:rgba(255,255,255,0.02);padding:6px 8px;border-radius:8px;border:1px solid rgba(255,255,255,0.02)}
.console{background:rgba(0,0,0,0.08);padding:8px;border-radius:8px;flex-basis:260px;overflow:auto;font-family:monospace;color:#bfe0ff}
.slider{width:100%}
.rangeVal{float:right;color:var(--muted);font-weight:700}
.footer{margin-top:auto;font-size:12px;color:var(--muted)}
.target-mark{position:absolute;border-radius:50%;pointer-events:none;mix-blend-mode:screen}
</style>
</head>
<body>
<div class="app">
  <div class="left">
    <div><div class="h1">IMU Aim — Revamp</div><div class="small muted">3D preview, improved smoothing, sensitivity curve & prediction</div></div>

    <div class="control">
      <div class="row"><button id="btnWs" class="btn">Connect WS</button><button id="btnSerial" class="btn">Connect Serial</button><div style="flex:1"></div><div id="conn" class="badge">Disconnected</div></div>
      <div class="small" style="margin-top:8px">Auto Recenter <input id="chkAutoRec" type="checkbox" checked style="margin-left:8px"></div>
    </div>

    <div class="control">
      <label class="small">Load calibration.json</label>
      <div class="row"><input id="fileCal" type="file" accept=".json"><button id="btnClear" class="btn">Clear</button><div style="flex:1"></div></div>
      <div id="calInfo" class="small muted" style="margin-top:6px">No calibration loaded</div>
    </div>

    <div class="control">
      <label class="small">Sensitivity <span id="sensVal" class="rangeVal">1.0</span></label>
      <input id="sens" class="slider" type="range" min="0.2" max="3.0" step="0.01" value="1">
      <label class="small" style="margin-top:8px">Curve expo (0=ease-in,1=linear,2=expo) <span id="curveVal" class="rangeVal">1.2</span></label>
      <input id="curve" class="slider" type="range" min="0" max="2" step="0.01" value="1.2">
      <label class="small" style="margin-top:8px">Smoothing (crit-damp alpha) <span id="smoothVal" class="rangeVal">0.88</span></label>
      <input id="smooth" class="slider" type="range" min="0.5" max="0.995" step="0.005" value="0.88">
      <label class="small" style="margin-top:8px">Deadzone (deg) <span id="dzVal" class="rangeVal">1.2</span></label>
      <input id="dz" class="slider" type="range" min="0" max="12" step="0.1" value="1.2">
    </div>

    <div class="control">
      <div class="row"><button id="btnRecenter" class="btn">Quick Recenter</button><button id="btnReset" class="btn">Reset Baseline</button><div style="flex:1"></div><div id="base" class="badge">Baseline:none</div></div>
    </div>

    <div class="control">
      <div class="row"><button id="btnStart" class="btn">Start Game</button><button id="btnStop" class="btn">Stop</button><div style="flex:1"></div><div class="small">Score: <span id="score">0</span></div></div>
    </div>

    <div class="control" style="margin-top:12px">
      <div class="small">Telemetry</div>
      <div id="log" class="console">idle.</div>
    </div>

    <div class="footer">Improvements: 3D preview, better smoothing, sensitivity curve, prediction, WS aim emit.</div>
  </div>

  <div class="right">
    <div class="hud">
      <div class="badge" id="mode">idle</div>
      <div style="flex:1"></div>
      <div class="badge" id="hz">— Hz</div>
      <div style="width:10px"></div>
      <div class="badge" id="euler">—</div>
    </div>

    <div class="canvasWrap">
      <div id="view3d"></div>
      <div id="rightSide" style="display:flex;flex-direction:column;gap:8px;width:320px">
        <canvas id="gameCanvas" style="width:100%;height:360px;border-radius:8px;background:#021426"></canvas>
        <div style="display:flex;gap:8px">
          <div class="small">Raw q</div><div id="rawq" class="badge">—</div>
          <div style="flex:1"></div>
          <div class="small">Cal Euler</div><div id="caleuler" class="badge">—</div>
        </div>
        <div id="miniGraph" style="height:100px;background:linear-gradient(#021022,#041022);border-radius:8px;border:1px solid rgba(255,255,255,0.02)"></div>
      </div>
    </div>

  </div>
</div>

<!-- Three.js -->
<script type="module">
import * as THREE from 'https://unpkg.com/three@0.154.0/build/three.module.js';

(() => {
  // DOM
  const btnWs = document.getElementById('btnWs'), btnSerial = document.getElementById('btnSerial'), conn = document.getElementById('conn');
  const fileCal = document.getElementById('fileCal'), btnClear = document.getElementById('btnClear'), calInfo = document.getElementById('calInfo');
  const chkAutoRec = document.getElementById('chkAutoRec'), btnRecenter = document.getElementById('btnRecenter'), btnReset = document.getElementById('btnReset');
  const sensEl = document.getElementById('sens'), sensVal = document.getElementById('sensVal');
  const smoothEl = document.getElementById('smooth'), smoothVal = document.getElementById('smoothVal');
  const curveEl = document.getElementById('curve'), curveVal = document.getElementById('curveVal');
  const dzEl = document.getElementById('dz'), dzVal = document.getElementById('dzVal');
  const btnStart = document.getElementById('btnStart'), btnStop = document.getElementById('btnStop'), scoreEl = document.getElementById('score');
  const logEl = document.getElementById('log'), modeEl = document.getElementById('mode');
  const hzEl = document.getElementById('hz'), eulerEl = document.getElementById('euler');
  const rawq = document.getElementById('rawq'), caleuler = document.getElementById('caleuler');

  // Websocket / Serial state
  let ws = null, wsConnected = false;
  let port = null, reader = null, keepReading=false;

  // Calibration
  let cal = null;
  let q0 = null;           // baseline [w,x,y,z]
  let qg = null;           // quaternion corresponding to R_global if present
  let autoRecenter = true;

  // smoothing + mapping
  let sensitivity = parseFloat(sensEl.value), smoothing = parseFloat(smoothEl.value), curve = parseFloat(curveEl.value), deadzone = parseFloat(dzEl.value);
  sensVal.textContent = sensitivity.toFixed(2); smoothVal.textContent = smoothing.toFixed(3); curveVal.textContent = curve.toFixed(2); dzVal.textContent = deadzone.toFixed(1);

  // Game
  let running=false, score=0, target={x:0.6,y:0.45,size:0.12};

  // telemetry
  let lastQuat=null, frames=0, lastFrameTime=performance.now();

  // smoothing: critically-damped second-order filter
  function makeCriticallyDamped() {
    return { x:0, vx:0, y:0, vy:0, initialized:false };
  }
  const filt = makeCriticallyDamped();

  function critd_update(targetX, targetY, dt, omega = 20) {
    // omega controls responsiveness; adjust with smoothing parameter
    // damping ratio = 1 (critically damped)
    if (!filt.initialized) { filt.x = targetX; filt.y = targetY; filt.vx = 0; filt.vy=0; filt.initialized=true; }
    // implement second-order: x'' + 2*omega*x' + omega^2*(x - target) = 0
    const k = omega*omega;
    const c = 2*omega;
    // integrate simple semi-implicit Euler
    // acceleration
    const ax = -c * filt.vx - k * (filt.x - targetX);
    const ay = -c * filt.vy - k * (filt.y - targetY);
    // velocity update
    filt.vx += ax * dt;
    filt.vy += ay * dt;
    // position update
    filt.x += filt.vx * dt;
    filt.y += filt.vy * dt;
    return { x: filt.x, y: filt.y };
  }

  // 3D scene: two cubes (raw and calibrated)
  const container = document.getElementById('view3d');
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x071427);
  const camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
  camera.position.set(2.8, 1.8, 3.2);
  const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
  renderer.setSize(container.clientWidth, container.clientHeight);
  container.appendChild(renderer.domElement);

  window.addEventListener('resize', ()=>{ renderer.setSize(container.clientWidth, container.clientHeight); camera.aspect = container.clientWidth / container.clientHeight; camera.updateProjectionMatrix(); });

  const hemi = new THREE.HemisphereLight(0xffffff, 0x111111, 0.9); scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.8); dir.position.set(5,6,3); scene.add(dir);
  const grid = new THREE.GridHelper(6, 12, 0x1b3c44, 0x0b2230); scene.add(grid);

  // Raw cube (left)
  const geo = new THREE.BoxGeometry(0.9,0.5,1.4);
  const matRaw = new THREE.MeshStandardMaterial({ color:0xff8a8a, metalness:0.1, roughness:0.5 });
  const cubeRaw = new THREE.Mesh(geo, matRaw);
  cubeRaw.position.x = -1.1;
  scene.add(cubeRaw);
  // calibrated cube (right)
  const matCal = new THREE.MeshStandardMaterial({ color:0x78a1ff, metalness:0.15, roughness:0.35 });
  const cubeCal = new THREE.Mesh(geo, matCal);
  cubeCal.position.x = 1.1;
  scene.add(cubeCal);
  // axes
  const axesRaw = new THREE.AxesHelper(0.9); axesRaw.position.copy(cubeRaw.position); scene.add(axesRaw);
  const axesCal = new THREE.AxesHelper(0.9); axesCal.position.copy(cubeCal.position); scene.add(axesCal);

  let lastRender = performance.now();
  function animate() {
    requestAnimationFrame(animate);
    // gentle orbit
    const t = performance.now()*0.0002;
    camera.position.x = Math.cos(t*0.6)*4;
    camera.position.z = Math.sin(t*0.6)*4;
    camera.lookAt(0,0,0);
    renderer.render(scene, camera);
  }
  animate();

  // Canvas for game
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  function resizeCanvas() {
    canvas.width = canvas.clientWidth * devicePixelRatio;
    canvas.height = canvas.clientHeight * devicePixelRatio;
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  function drawGame() {
    const w = canvas.clientWidth, h = canvas.clientHeight;
    ctx.clearRect(0,0,w,h);
    // background
    const g = ctx.createLinearGradient(0,0,w,h); g.addColorStop(0,'#031426'); g.addColorStop(1,'#011122'); ctx.fillStyle = g; ctx.fillRect(0,0,w,h);
    // target
    const tx = target.x * w, ty = target.y * h, r = target.size * Math.min(w,h);
    ctx.beginPath(); ctx.arc(tx,ty,r,0,Math.PI*2); ctx.fillStyle = 'rgba(255,130,120,0.06)'; ctx.fill(); ctx.lineWidth = 2; ctx.strokeStyle='rgba(255,130,120,0.6)'; ctx.stroke();
    // crosshair
    const cx = w/2 + filt.x * (w/2*0.9), cy = h/2 - filt.y * (h/2*0.9); // filt holds smoothed -1..1
    ctx.strokeStyle = '#78a1ff'; ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(cx-12,cy); ctx.lineTo(cx+12,cy); ctx.moveTo(cx,cy-12); ctx.lineTo(cx,cy+12); ctx.stroke();
    ctx.fillStyle = '#78a1ff'; ctx.beginPath(); ctx.arc(cx,cy,4,0,Math.PI*2); ctx.fill();
    requestAnimationFrame(drawGame);
  }
  drawGame();

  // small mini graph for delta
  const mini = document.getElementById('miniGraph');
  const miniCtx = document.createElement('canvas').getContext('2d');
  mini.appendChild(miniCtx.canvas);
  function resizeMini(){
    miniCtx.canvas.width = mini.clientWidth * devicePixelRatio;
    miniCtx.canvas.height = mini.clientHeight * devicePixelRatio;
    miniCtx.canvas.style.width = mini.clientWidth + 'px';
    miniCtx.canvas.style.height = mini.clientHeight + 'px';
    miniCtx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  }
  window.addEventListener('resize', resizeMini);
  resizeMini();
  const dBuf = [];
  function drawMini(){
    const w = mini.clientWidth, h = mini.clientHeight;
    miniCtx.clearRect(0,0,w,h);
    miniCtx.fillStyle='#021426'; miniCtx.fillRect(0,0,w,h);
    if (dBuf.length>0){
      const maxv = Math.max(...dBuf,0.001);
      miniCtx.beginPath(); miniCtx.moveTo(0,h);
      for (let i=0;i<dBuf.length;i++){
        const x = (i/(dBuf.length-1))*w; const y = h - (dBuf[i]/maxv)*(h*0.9);
        miniCtx.lineTo(x,y);
      }
      miniCtx.lineTo(w,h); miniCtx.closePath();
      miniCtx.fillStyle='rgba(120,161,255,0.12)'; miniCtx.fill();
      miniCtx.strokeStyle='#78a1ff'; miniCtx.lineWidth=2; miniCtx.stroke();
    }
    requestAnimationFrame(drawMini);
  }
  drawMini();

  // Quaternion utilities (arrays [w,x,y,z])
  function normalizeQ(q){ const n = Math.hypot(q[0],q[1],q[2],q[3]); if (!isFinite(n)||n<1e-12) return [1,0,0,0]; return [q[0]/n,q[1]/n,q[2]/n,q[3]/n]; }
  function quatConj(q){ return [q[0], -q[1], -q[2], -q[3]]; }
  function quatMul(a,b){ const w1=a[0],x1=a[1],y1=a[2],z1=a[3]; const w2=b[0],x2=b[1],y2=b[2],z2=b[3]; return [ w1*w2 - x1*x2 - y1*y2 - z1*z2, w1*x2 + x1*w2 + y1*z2 - z1*y2, w1*y2 - x1*z2 + y1*w2 + z1*x2, w1*z2 + x1*y2 - y1*x2 + z1*w2 ]; }
  function quatToEulerZYX(q){ const w=q[0],x=q[1],y=q[2],z=q[3]; const sinr=2*(w*x + y*z), cosr = 1 - 2*(x*x+y*y); const roll = Math.atan2(sinr, cosr); const sinp = 2*(w*y - z*x); let pitch = 0; if (Math.abs(sinp)>=1) pitch = Math.sign(sinp)*Math.PI/2; else pitch = Math.asin(sinp); const siny=2*(w*z + x*y), cosy = 1 - 2*(y*y+z*z); const yaw = Math.atan2(siny, cosy); return {roll,pitch,yaw}; }
  function matrixToQuat(R){ // 3x3 array
    const m00=R[0][0], m11=R[1][1], m22=R[2][2];
    const tr = m00 + m11 + m22;
    let w,x,y,z;
    if (tr>0){ const S = Math.sqrt(tr+1.0)*2; w=0.25*S; x=(R[2][1]-R[1][2])/S; y=(R[0][2]-R[2][0])/S; z=(R[1][0]-R[0][1])/S; }
    else if (m00>m11 && m00>m22){ const S=Math.sqrt(1.0 + m00 - m11 - m22)*2; w=(R[2][1]-R[1][2])/S; x=0.25*S; y=(R[0][1]+R[1][0])/S; z=(R[0][2]+R[2][0])/S; }
    else if (m11>m22){ const S=Math.sqrt(1.0 + m11 - m00 - m22)*2; w=(R[0][2]-R[2][0])/S; x=(R[0][1]+R[1][0])/S; y=0.25*S; z=(R[1][2]+R[2][1])/S; }
    else { const S=Math.sqrt(1.0 + m22 - m00 - m11)*2; w=(R[1][0]-R[0][1])/S; x=(R[0][2]+R[2][0])/S; y=(R[1][2]+R[2][1])/S; z=0.25*S; }
    return normalizeQ([w,x,y,z]);
  }

  // Apply calibration: q_in -> q_out
  function applyCalibration(q_in){
    if (!q_in) return null;
    let q_rel = q0 ? quatMul(quatConj(q0), q_in) : q_in.slice();
    q_rel = normalizeQ(q_rel);
    let q_out = q_rel;
    if (qg) q_out = quatMul(qg, q_rel);
    return normalizeQ(q_out);
  }

  // Process incoming quaternion (raw [w,x,y,z])
  let lastQRaw = null;
  function onQuat(q_in){
    lastQRaw = q_in.slice(0,4).map(Number);
    lastQRaw = normalizeQ(lastQRaw);
    // update raw cube
    const qrawTH = new THREE.Quaternion(lastQRaw[1], lastQRaw[2], lastQRaw[3], lastQRaw[0]); // THREE uses (x,y,z,w)
    cubeRaw.quaternion.copy(qrawTH);
    // apply calibration
    const q_out = applyCalibration(lastQRaw);
    if (!q_out) return;
    const qcalTH = new THREE.Quaternion(q_out[1], q_out[2], q_out[3], q_out[0]);
    cubeCal.quaternion.copy(qcalTH);
    // update UI
    rawq.textContent = `[${lastQRaw.map(v=>v.toFixed(4)).join(', ')}]`;
    const eC = quatToEulerZYX(q_out); caleuler.textContent = `Y:${(eC.yaw*180/Math.PI).toFixed(1)}°, P:${(eC.pitch*180/Math.PI).toFixed(1)}°`;
    eulerEl.textContent = `Y:${(eC.yaw*180/Math.PI).toFixed(1)} P:${(eC.pitch*180/Math.PI).toFixed(1)}`;
    // mapping yaw/pitch to [-1..1]
    let xVal = eC.yaw, yVal = eC.pitch; // yaw->x, pitch->y
    // deadzone
    const dz = deadzone*Math.PI/180;
    if (Math.abs(xVal) < dz) xVal = 0;
    if (Math.abs(yVal) < dz) yVal = 0;
    // sensitivity curve: apply exponent curve then tanh normalization
    const applyCurve = (v) => {
      // v in radians; returns bounded -1..1
      const scaled = v * sensitivity;
      const c = curve;
      // apply signed power curve
      const sgn = Math.sign(scaled);
      const mag = Math.abs(scaled);
      const cur = Math.pow(mag, 1 + c*0.5);
      return Math.tanh(sgn * cur);
    }
    const nx = applyCurve(xVal), ny = applyCurve(yVal);
    // prediction: approximate angular velocity
    // we don't have timestamps per-sample reliably here; do a tiny prediction using frame delta
    const now = performance.now(); frames++;
    const dt = Math.max(0.001, (now - lastFrameTime)/1000);
    lastFrameTime = now;
    // update mini graph delta (distance between quats)
    if (lastQRawPrev){
      const dq = Math.hypot(lastQRaw[0]-lastQRawPrev[0], lastQRaw[1]-lastQRawPrev[1], lastQRaw[2]-lastQRawPrev[2], lastQRaw[3]-lastQRawPrev[3]);
      dBuf.push(dq); if (dBuf.length>120) dBuf.shift();
    }
    lastQRawPrev = lastQRaw.slice();
    // smoothing / prediction: use critically damped filter with omega scaled by smoothing param
    // map smoothing slider (0.5..0.995) to omega (fast->slow)
    const omega = 6 + (1-(smoothing-0.5)/0.495)*40; // map to ~6..46
    const sres = critd_update(nx, ny, dt, omega);
    // feed to filt which is used by drawGame
    // spawn target logic (scoring) — simple: if smoothed crosshair inside target, score and nudge target
    filt.x = sres.x; filt.y = sres.y;
    // increment frames -> update hz shown
    if (!isNaN(dt)){
      // nothing else
    }
  }

  // minimal line parser for serial / ws messages
  function handleLine(line){
    try {
      const obj = JSON.parse(line);
      if (obj.type === 'imu' && Array.isArray(obj.quat) && obj.quat.length>=4){
        // if MCU sends [x,y,z,w] toggle or check; assume [w,x,y,z] as you said
        onQuat(obj.quat.slice(0,4).map(Number));
      } else {
        logEl.textContent = (line + "\n") + logEl.textContent;
      }
    } catch(err) {
      logEl.textContent = ('parse err: '+err+' => '+line + "\n") + logEl.textContent;
    }
  }

  // WebSocket connect
  btnWs.addEventListener('click', ()=>{
    if (ws && wsConnected) { ws.close(); return; }
    const url = 'ws://localhost:8766';
    ws = new WebSocket(url);
    modeEl.textContent = 'ws';
    ws.onopen = ()=>{ wsConnected=true; conn.textContent='WS'; conn.style.background='#072'; logEl.textContent = 'WS connected\n' + logEl.textContent; if (chkAutoRec.checked) { setTimeout(()=>{ if (lastQRaw){ q0 = lastQRaw.slice(); baseText(); logEl.textContent='Auto quick recenter on connect\n' + logEl.textContent } }, 300); } };
    ws.onmessage = (ev)=> handleLine(ev.data);
    ws.onclose = ()=>{ wsConnected=false; conn.textContent='Disconnected'; modeEl.textContent='idle'; logEl.textContent = 'WS closed\n' + logEl.textContent; };
    ws.onerror = (e)=> { logEl.textContent = 'WS error\n' + logEl.textContent; };
  });

  // Web Serial
  btnSerial.addEventListener('click', async ()=>{
    if (port){ keepReading=false; try{ await reader.cancel(); } catch{} try{ await port.close(); } catch{} port=null; conn.textContent='Disconnected'; modeEl.textContent='idle'; return; }
    try {
      port = await navigator.serial.requestPort();
      await port.open({ baudRate:115200 });
      conn.textContent = 'Serial'; modeEl.textContent='serial'; logEl.textContent = 'Serial opened\n' + logEl.textContent;
      const textDecoder = new TextDecoderStream();
      const inputDone = port.readable.pipeTo(textDecoder.writable);
      reader = textDecoder.readable.pipeThrough(new TransformStream(new LineBreakTransformer())).getReader();
      keepReading = true;
      (async function readLoop(){
        while (keepReading){
          try {
            const { value, done } = await reader.read();
            if (done) break;
            if (value) handleLine(value);
          } catch(e){ logEl.textContent = 'Serial read error: '+e + '\n' + logEl.textContent; break; }
        }
      })();
      // auto recenter if enabled
      if (chkAutoRec.checked && lastQRaw) { q0 = lastQRaw.slice(); baseText(); logEl.textContent='Auto quick recenter on serial connect\n' + logEl.textContent; }
    } catch(e){
      logEl.textContent = 'Serial connect error: '+e + '\n' + logEl.textContent;
    }
  });

  // line transformer
  class LineBreakTransformer {
    constructor(){ this.container = ''; }
    transform(chunk, controller){ this.container += chunk; const lines = this.container.split(/\r?\n/); this.container = lines.pop(); lines.forEach(l=>controller.enqueue(l)); }
    flush(controller){ if (this.container) controller.enqueue(this.container); }
  }

  // file load
  fileCal.addEventListener('change', (ev)=>{
    const f = ev.target.files[0]; if (!f) return;
    const r = new FileReader();
    r.onload = e => {
      try {
        cal = JSON.parse(e.target.result);
        calInfo.textContent = 'Loaded';
        if (cal.baseline_quaternion) { q0 = cal.baseline_quaternion.slice(0,4); baseText(); }
        if (cal.R_global) { qg = matrixToQuat(cal.R_global); }
        logEl.textContent = 'Loaded calibration.json\n' + logEl.textContent;
      } catch(err){ logEl.textContent = 'Bad cal JSON: '+err+'\n' + logEl.textContent; }
    };
    r.readAsText(f);
  });
  btnClear.addEventListener('click', ()=>{ cal=null; q0=null; qg=null; calInfo.textContent='No calibration'; baseText(); logEl.textContent='Cleared calibration\n' + logEl.textContent; });

  function baseText(){ base.textContent = q0 ? 'Baseline: set' : 'Baseline: none'; }

  // Quick recenter
  btnRecenter.addEventListener('click', ()=>{ if (!lastQRaw) { logEl.textContent='No recent sample\n' + logEl.textContent; return; } q0 = lastQRaw.slice(); baseText(); logEl.textContent = 'Quick recenter set\n' + logEl.textContent; });
  btnReset.addEventListener('click', ()=>{ q0=null; baseText(); logEl.textContent='Baseline reset\n' + logEl.textContent; });

  // sliders
  sensEl.addEventListener('input', ()=>{ sensitivity = parseFloat(sensEl.value); sensVal.textContent = sensitivity.toFixed(2); });
  smoothEl.addEventListener('input', ()=>{ smoothing = parseFloat(smoothEl.value); smoothVal.textContent = smoothing.toFixed(3); });
  curveEl.addEventListener('input', ()=>{ curve = parseFloat(curveEl.value); curveVal.textContent = curve.toFixed(2); });
  dzEl.addEventListener('input', ()=>{ deadzone = parseFloat(dzEl.value); dzVal.textContent = deadzone.toFixed(1); });

  // Game loop: scoring
  function tickGame(){
    if (!running) return;
    // check hit
    const w = canvas.clientWidth, h = canvas.clientHeight;
    const cx = w/2 + filt.x * (w/2*0.9), cy = h/2 - filt.y * (h/2*0.9);
    const tx = target.x * w, ty = target.y * h; const r = target.size * Math.min(w,h);
    if (Math.hypot(cx-tx, cy-ty) < r){
      score++; scoreEl.textContent = score;
      // move target
      target.x = 0.15 + Math.random()*0.7; target.y = 0.15 + Math.random()*0.7;
    }
    setTimeout(tickGame, 200);
  }

  btnStart.addEventListener('click', ()=>{ running=true; score=0; scoreEl.textContent=score; tickGame(); });
  btnStop.addEventListener('click', ()=>{ running=false; });

  // small hz updater
  setInterval(()=>{ const now = performance.now(); let elapsed = (now - lastFrameTime)/1000; if (elapsed>0){ hzEl.textContent = Math.round(frames/Math.max(0.001,elapsed)) + ' Hz'; frames=0; lastFrameTime=now; } }, 800);

  // helper: convert R_global -> quaternion
  function matrixToQuat(R) {
    return matrixToQuatImpl(R); // reuse function above defined
  }

  // tiny wrapper to reuse earlier matrix->quat impl
  function matrixToQuatImpl(R) {
    const m00=R[0][0], m01=R[0][1], m02=R[0][2], m10=R[1][0], m11=R[1][1], m12=R[1][2], m20=R[2][0], m21=R[2][1], m22=R[2][2];
    const tr = m00 + m11 + m22;
    let w,x,y,z;
    if (tr>0){ let S=Math.sqrt(tr+1.0)*2; w=0.25*S; x=(m21-m12)/S; y=(m02-m20)/S; z=(m10-m01)/S; }
    else if (m00>m11 && m00>m22){ let S=Math.sqrt(1.0+m00-m11-m22)*2; w=(m21-m12)/S; x=0.25*S; y=(m01+m10)/S; z=(m02+m20)/S; }
    else if (m11>m22){ let S=Math.sqrt(1.0+m11-m00-m22)*2; w=(m02-m20)/S; x=(m01+m10)/S; y=0.25*S; z=(m12+m21)/S; }
    else { let S=Math.sqrt(1.0+m22-m00-m11)*2; w=(m10-m01)/S; x=(m02+m20)/S; y=(m12+m21)/S; z=0.25*S; }
    return normalizeQ([w,x,y,z]);
  }

  // expose applyCalibration for debugging
  window._applyCalibration = applyCalibration;

  // last raw for delta
  let lastQRawPrev = null;

  // finished
  logEl.textContent = 'Ready — improved revamp loaded\n' + logEl.textContent;

})();
</script>
</body>
</html>
