<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>IMU → Cursor Mapper</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;600;800&display=swap" rel="stylesheet">
<style>
:root{
  --bg:#061025; --panel:#07172b; --muted:#9fb3d6; --accent:#78a1ff; --good:#86efac; --danger:#ff6b6b;
}
html,body{height:100%;margin:0;background:linear-gradient(180deg,#02061a 0%,#041427 100%);font-family:Inter,system-ui,Arial;color:#e7f3ff}
.app{display:flex;gap:12px;padding:14px;height:100vh;box-sizing:border-box}
.left{width:380px;background:var(--panel);border-radius:12px;padding:16px;box-sizing:border-box;border:1px solid rgba(255,255,255,0.03);display:flex;flex-direction:column}
.right{flex:1;background:linear-gradient(180deg,#051024,#031024);border-radius:12px;padding:12px;box-sizing:border-box;border:1px solid rgba(255,255,255,0.03);display:flex;flex-direction:column}
.h1{font-size:18px;font-weight:800;margin:0}
.small{font-size:13px;color:var(--muted)}
.row{display:flex;gap:8px;align-items:center}
.btn{background:#082231;border:1px solid #12303f;color:#eaf6ff;padding:8px 10px;border-radius:8px;cursor:pointer;font-weight:700}
.input{background:#071022;border:1px solid #12303f;color:#e6eef6;padding:8px;border-radius:8px;width:100%}
.selector{padding:6px;border-radius:8px;background:#071022;border:1px solid #12303f;color:#e6eef6}
.panel{margin-top:10px}
#view3d{height:420px;border-radius:8px;border:1px solid rgba(255,255,255,0.02);overflow:hidden}
.canvasWrap{position:relative}
#virtualCursor{position:absolute;width:16px;height:16px;border-radius:50%;background:#78a1ff;left:50%;top:50%;transform:translate(-50%,-50%);pointer-events:none;box-shadow:0 0 8px rgba(120,161,255,0.14)}
.footer{margin-top:auto;color:var(--muted);font-size:12px}
.badge{background:rgba(255,255,255,0.02);padding:6px 8px;border-radius:8px;border:1px solid rgba(255,255,255,0.02);font-weight:700}
.console{background:rgba(0,0,0,0.08);padding:8px;border-radius:8px;color:#bfe0ff; height:120px; overflow:auto;font-family:monospace}
.inline{display:inline-flex;gap:6px;align-items:center}
.mappingInputs{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px}
</style>
</head>
<body>
<div class="app">
  <div class="left">
    <div><div class="h1">IMU → Mouse Mapper</div><div class="small">Enter mapping or use auto-map from diagnostic. Works with WS or WebSerial. Local bridge included.</div></div>

    <div class="panel">
      <div class="small">Connection</div>
      <div class="row" style="margin-top:8px;">
        <button id="btnWS" class="btn">Connect WS</button>
        <button id="btnSerial" class="btn">Connect Serial</button>
        <div style="flex:1"></div>
        <div id="connBadge" class="badge">idle</div>
      </div>
      <div class="small" style="margin-top:8px">WebSocket bridge sends IMU JSON to <code>ws://localhost:8766</code> by default.</div>
    </div>

    <div class="panel">
      <div class="small">Mapping (paste or type)</div>
      <div style="margin-top:8px" class="mappingInputs">
        <select id="xAxis" class="selector">
          <option value="roll">roll</option><option value="pitch">pitch</option><option value="yaw">yaw</option>
        </select>
        <select id="yAxis" class="selector">
          <option value="yaw">yaw</option><option value="pitch">pitch</option><option value="roll">roll</option>
        </select>
        <label class="inline small"><input id="invX" type="checkbox"> Invert X</label>
        <label class="inline small"><input id="invY" type="checkbox"> Invert Y</label>
      </div>
      <div style="margin-top:8px" class="row">
        <button id="applyMapping" class="btn">Apply Mapping</button>
        <button id="loadExample" class="btn">Load Provided</button>
        <div style="flex:1"></div>
        <div id="mapBadge" class="badge">map not set</div>
      </div>
    </div>

    <div class="panel">
      <div class="small">Control</div>
      <div style="margin-top:8px;">
        <label class="small">Sensitivity <span id="sensV" style="float:right">1.00</span></label>
        <input id="sens" type="range" min="0.2" max="4.0" step="0.01" value="1" class="input">
        <label class="small" style="margin-top:8px">Smoothing <span id="smoothV" style="float:right">0.88</span></label>
        <input id="smooth" type="range" min="0" max="0.98" step="0.01" value="0.88" class="input">
        <label class="small" style="margin-top:8px">Deadzone (deg) <span id="dzV" style="float:right">1.5</span></label>
        <input id="deadzone" type="range" min="0" max="10" step="0.1" value="1.5" class="input">
        <div style="margin-top:8px" class="row">
          <button id="btnRecenter" class="btn">Quick Recenter</button>
          <button id="btnResetBase" class="btn">Reset Baseline</button>
          <div style="flex:1"></div>
          <div id="baseBadge" class="badge">baseline: none</div>
        </div>
      </div>
    </div>

    <div class="panel">
      <div class="small">Options</div>
      <label class="inline small"><input id="emitWs" type="checkbox" checked> Emit aim events over WS (ws://localhost:8766)</label>
      <div class="small" style="margin-top:6px">When WS is enabled the page sends processed aim {nx,ny} to your local bridge for real OS mouse motion.</div>
    </div>

    <div class="panel" style="margin-top:10px">
      <div class="small">Telemetry</div>
      <div id="console" class="console">Waiting for IMU...</div>
    </div>

    <div class="footer small">No browser console required. Use the Python bridge provided to move the real mouse.</div>
  </div>

  <div class="right">
    <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
      <div class="badge" id="hzBadge">— Hz</div>
      <div style="flex:1"></div>
      <div class="badge" id="eulBadge">—</div>
    </div>

    <div id="view3d" class="canvasWrap">
      <!-- three.js canvas inserted here -->
      <div id="virtualCursor"></div>
    </div>

    <div style="margin-top:10px;display:flex;gap:8px;align-items:center">
      <div class="small">Raw quat</div><div id="rawq" class="badge">—</div>
      <div style="flex:1"></div>
      <div class="small">Cal euler</div><div id="caleul" class="badge">—</div>
    </div>
  </div>
</div>

<script type="module">
// IMU → Cursor Mapper (client side)
// Features:
//  - Accept IMU JSON lines via WebSocket or WebSerial
//  - Apply baseline recenter, mapping, invert flags you enter
//  - Smoothing (EMA), sensitivity, deadzone
//  - In-page virtual cursor for testing
//  - Optionally emit processed aim {nx,ny} to ws://localhost:8766/aim for local bridge

import * as THREE from 'https://unpkg.com/three@0.154.0/build/three.module.js';

// DOM
const btnWS = document.getElementById('btnWS');
const btnSerial = document.getElementById('btnSerial');
const connBadge = document.getElementById('connBadge');
const consoleEl = document.getElementById('console');
const hzBadge = document.getElementById('hzBadge');
const eulBadge = document.getElementById('eulBadge');

const xAxisSel = document.getElementById('xAxis');
const yAxisSel = document.getElementById('yAxis');
const invXEl = document.getElementById('invX');
const invYEl = document.getElementById('invY');
const applyMappingBtn = document.getElementById('applyMapping');
const loadExampleBtn = document.getElementById('loadExample');
const mapBadge = document.getElementById('mapBadge');

const sensSlider = document.getElementById('sens');
const sensV = document.getElementById('sensV');
const smoothSlider = document.getElementById('smooth');
const smoothV = document.getElementById('smoothV');
const dzSlider = document.getElementById('deadzone');
const dzV = document.getElementById('dzV');
const btnRecenter = document.getElementById('btnRecenter');
const btnResetBase = document.getElementById('btnResetBase');
const baseBadge = document.getElementById('baseBadge');
const rawqEl = document.getElementById('rawq');
const caleulEl = document.getElementById('caleul');
const virtualCursor = document.getElementById('virtualCursor');
const emitWsChk = document.getElementById('emitWs');

// fill with user's mapping (from message)
const defaultMapping = { xAxis: "pitch", yAxis: "roll", invX: false, invY: true };
function loadDefaultMapping(){
  xAxisSel.value = defaultMapping.xAxis;
  yAxisSel.value = defaultMapping.yAxis;
  invXEl.checked = defaultMapping.invX;
  invYEl.checked = defaultMapping.invY;
  mapBadge.textContent = 'mapping loaded';
}
loadDefaultMapping();

// state
let ws = null;        // websocket for incoming IMU (not the emit ws)
let emitWs = null;    // ws to emit aim events to local bridge
let port = null;      // serial port
let reader = null;
let keepReading = false;
let lastQuat = null; // [w,x,y,z]
let baseline = null;
let lastApplied = { x:0, y:0 };
let freqCounter = 0;
let lastFreqTime = performance.now();

let sampleRateHz = 0;

// smoothing
let smoothState = { x:0, y:0, init:false };

// three.js quick scene
const container = document.getElementById('view3d');
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x071427);
const camera = new THREE.PerspectiveCamera(55, container.clientWidth/container.clientHeight, 0.1, 100);
camera.position.set(2.5,1.8,3.2);
const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
renderer.setSize(container.clientWidth, container.clientHeight);
container.appendChild(renderer.domElement);
window.addEventListener('resize', ()=>{ renderer.setSize(container.clientWidth, container.clientHeight); camera.aspect = container.clientWidth / container.clientHeight; camera.updateProjectionMatrix(); });

const hemi = new THREE.HemisphereLight(0xffffff, 0x111111, 0.9); scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 0.8); dir.position.set(3,4,2); scene.add(dir);
const grid = new THREE.GridHelper(6,12,0x1b3c44,0x0b2230); scene.add(grid);

const cube = new THREE.Mesh(new THREE.BoxGeometry(1.0,0.6,1.4), new THREE.MeshStandardMaterial({ color:0x78a1ff, metalness:0.2, roughness:0.35 }));
scene.add(cube);
const axes = new THREE.AxesHelper(1.2); scene.add(axes);

(function animate(){ requestAnimationFrame(animate); const t=performance.now()*0.00015; camera.position.x = Math.cos(t)*4; camera.position.z = Math.sin(t)*4; camera.position.y = 2.2+Math.sin(t*0.9)*0.3; camera.lookAt(0,0,0); renderer.render(scene,camera); })();

// helpers: quaternion math (arrays [w,x,y,z])
function normalizeQ(q){
  const n = Math.hypot(q[0],q[1],q[2],q[3]);
  if (!isFinite(n) || n < 1e-12) return [1,0,0,0];
  return [q[0]/n, q[1]/n, q[2]/n, q[3]/n];
}
function quatConj(q){ return [q[0], -q[1], -q[2], -q[3]]; }
function quatMul(a,b){ const [w1,x1,y1,z1]=a, [w2,x2,y2,z2]=b; return [ w1*w2 - x1*x2 - y1*y2 - z1*z2, w1*x2 + x1*w2 + y1*z2 - z1*y2, w1*y2 - x1*z2 + y1*w2 + z1*x2, w1*z2 + x1*y2 - y1*x2 + z1*w2 ]; }
function quatToEulerZYX(q){ const [w,x,y,z]=q; const sinr=2*(w*x + y*z); const cosr=1-2*(x*x+y*y); const roll=Math.atan2(sinr, cosr); const sinp=2*(w*y - z*x); const pitch = Math.abs(sinp)>=1 ? Math.sign(sinp)*Math.PI/2 : Math.asin(sinp); const siny = 2*(w*z + x*y); const cosy=1-2*(y*y+z*z); const yaw=Math.atan2(siny, cosy); return {roll,pitch,yaw}; }

// mapping application
function getMapping(){
  return { xAxis: xAxisSel.value, yAxis: yAxisSel.value, invX: invXEl.checked, invY: invYEl.checked };
}
function applyMappingObject(m){ xAxisSel.value = m.xAxis; yAxisSel.value = m.yAxis; invXEl.checked = !!m.invX; invYEl.checked = !!m.invY; mapBadge.textContent = 'applied'; }

// apply mapping + baseline + R_global (we don't support R_global file here) -> returns normalized screen coords [-1..1]
function processQuat(q_in){
  if (!q_in) return null;
  q_in = normalizeQ(q_in);
  // baseline: q_rel = inv(baseline) * q_in
  let q_rel = q_in;
  if (baseline){
    q_rel = quatMul(quatConj(baseline), q_in);
    q_rel = normalizeQ(q_rel);
  }
  // convert to euler ZYX
  const e = quatToEulerZYX(q_rel);
  // mapping
  const map = getMapping();
  const pick=(axis)=> axis==='roll'?e.roll:(axis==='pitch'?e.pitch:e.yaw);
  let vx = pick(map.xAxis);
  let vy = pick(map.yAxis);
  if (map.invX) vx = -vx;
  if (map.invY) vy = -vy;
  // deadzone
  const dzDeg = Number(dzSlider.value);
  const dz = dzDeg * Math.PI/180;
  if (Math.abs(vx) < dz) vx = 0;
  if (Math.abs(vy) < dz) vy = 0;
  // sensitivity mapping: use tanh curve for nicer center control
  const sens = Number(sensSlider.value);
  const nx = Math.tanh(vx * sens);
  const ny = Math.tanh(vy * sens);
  return { nx, ny, e, raw: q_in };
}

// smoothing: simple EMA controlled by smoothing slider (0..0.98)
function smooth(nx, ny){
  const s = Number(smoothSlider.value);
  if (!smoothState.init){ smoothState.x = nx; smoothState.y = ny; smoothState.init = true; }
  smoothState.x = smoothState.x * s + nx * (1 - s);
  smoothState.y = smoothState.y * s + ny * (1 - s);
  return { x: smoothState.x, y: smoothState.y };
}

// visual + emitting
function updateUIFromProcessed(p){
  if (!p) return;
  // update cube
  const q = p.raw; // calibrated raw quaternion
  // THREE Quaternion is (x,y,z,w)
  cube.quaternion.set(q[1], q[2], q[3], q[0]);
  rawqEl.textContent = `[${q.map(v=>v.toFixed(4)).join(', ')}]`;
  caleulEl.textContent = `Y:${(p.e.yaw*180/Math.PI).toFixed(1)}° P:${(p.e.pitch*180/Math.PI).toFixed(1)}° R:${(p.e.roll*180/Math.PI).toFixed(1)}°`;
  eulBadge.textContent = `Y:${(p.e.yaw*180/Math.PI).toFixed(1)} P:${(p.e.pitch*180/Math.PI).toFixed(1)} R:${(p.e.roll*180/Math.PI).toFixed(1)}`;

  // smoothing + virtual cursor
  const s = smooth(p.nx, p.ny);
  const cx = container.clientWidth/2 + s.x * (container.clientWidth/2 * 0.9);
  const cy = container.clientHeight/2 - s.y * (container.clientHeight/2 * 0.9);
  virtualCursor.style.left = cx + 'px';
  virtualCursor.style.top = cy + 'px';

  // emit to local bridge if enabled
  if (emitWsChk.checked && emitWs && emitWs.readyState === WebSocket.OPEN){
    // send normalized target in a compact message
    const msg = JSON.stringify({ type:'aim', nx: s.x, ny: s.y, ts: Date.now() });
    try { emitWs.send(msg); }
    catch(e){ /* ignore */ }
  }
}

// handle incoming line
function handleLine(line){
  if (!line) return;
  let obj = null;
  try { obj = JSON.parse(line); } catch(e){ appendConsole("non-json: "+line); return; }
  if (!obj) return;
  // prefer IMU type object
  if (obj.type === 'imu' && Array.isArray(obj.quat) && obj.quat.length >= 4){
    // expect [w,x,y,z] by default. try to auto-correct if [x,y,z,w]
    let q = obj.quat.slice(0,4).map(Number);
    if (Math.abs(q[0]) < 0.2 && Math.abs(q[3]) > 0.7){
      // likely [x,y,z,w]
      q = [q[3], q[0], q[1], q[2]];
    }
    lastQuat = q;
    freqCounter++;
    const now = performance.now();
    if (now - lastFreqTime > 1000){
      sampleRateHz = Math.round(freqCounter * 1000/(now - lastFreqTime));
      hzBadge.textContent = sampleRateHz + " Hz";
      freqCounter = 0; lastFreqTime = now;
    }
    const processed = processQuat(q);
    updateUIFromProcessed(processed);
    appendConsole(`q:${q.map(v=>v.toFixed(4)).join(', ')}  nx:${processed.nx.toFixed(3)} ny:${processed.ny.toFixed(3)}`);
  } else {
    appendConsole(JSON.stringify(obj).slice(0,200));
  }
}

function appendConsole(s){
  consoleEl.textContent = `[${(new Date()).toLocaleTimeString()}] ${s}\n` + consoleEl.textContent;
  if (consoleEl.textContent.length > 20000) consoleEl.textContent = consoleEl.textContent.slice(0,20000);
}

// WS input connect (for IMU stream)
btnWS.addEventListener('click', ()=>{
  if (ws && ws.readyState === WebSocket.OPEN){ ws.close(); return; }
  const url = "ws://localhost:8765"; // default for IMU->WS bridge (you can adapt)
  ws = new WebSocket(url);
  appendConsole("Connecting IMU WS -> " + url);
  ws.onopen = ()=>{ connBadge.textContent = 'ws-in'; connBadge.style.background = '#072'; appendConsole("WS connected"); };
  ws.onmessage = (ev)=> handleLine(ev.data);
  ws.onclose = ()=>{ connBadge.textContent = 'idle'; appendConsole("WS closed"); };
  ws.onerror = (e)=> appendConsole("WS error");
});

// Web Serial connect
btnSerial.addEventListener('click', async ()=>{
  if (port){
    // disconnect
    keepReading = false;
    try { await reader.cancel(); } catch(e){}
    try { await port.close(); } catch(e){}
    port = null; connBadge.textContent = 'idle'; appendConsole("Serial closed");
    return;
  }
  try {
    port = await navigator.serial.requestPort();
    await port.open({ baudRate: 115200 });
    connBadge.textContent = 'serial';
    appendConsole("Serial opened");
    const textDecoder = new TextDecoderStream();
    const readableStreamClosed = port.readable.pipeTo(textDecoder.writable);
    reader = textDecoder.readable.pipeThrough(new TransformStream(new LineBreakTransformer())).getReader();
    keepReading = true;
    readSerialLoop();
  } catch(e){
    appendConsole("Serial error: " + e);
  }
});

class LineBreakTransformer {
  constructor(){ this.container = ''; }
  transform(chunk, controller){
    this.container += chunk;
    const lines = this.container.split(/\r?\n/);
    this.container = lines.pop();
    lines.forEach(l => controller.enqueue(l));
  }
  flush(controller){ if (this.container) controller.enqueue(this.container); }
}
async function readSerialLoop(){
  while (keepReading && reader){
    try {
      const { value, done } = await reader.read();
      if (done) break;
      if (value) handleLine(value);
    } catch(e){ appendConsole("Read error: " + e); break; }
  }
}

// mapping UI handlers
applyMappingBtn.addEventListener('click', ()=>{
  const m = getMapping();
  mapBadge.textContent = `X<-${m.xAxis}${m.invX?':inv':''} Y<-${m.yAxis}${m.invY?':inv':''}`;
  appendConsole("Mapping applied: " + JSON.stringify(m));
});
loadExampleBtn.addEventListener('click', ()=>{ applyMappingObject(defaultMapping); appendConsole("Loaded provided mapping"); });

// recenter / reset baseline
btnRecenter.addEventListener('click', ()=>{
  if (!lastQuat){ appendConsole("No recent sample to recenter"); return; }
  baseline = normalizeQ(lastQuat);
  baseBadge.textContent = 'baseline: session';
  appendConsole("Quick recenter set");
});
btnResetBase.addEventListener('click', ()=>{ baseline = null; baseBadge.textContent = 'baseline: none'; appendConsole("Baseline cleared"); });

// smoothing & sliders
sensSlider.addEventListener('input', ()=> sensV.textContent = Number(sensSlider.value).toFixed(2));
smoothSlider.addEventListener('input', ()=> smoothV.textContent = Number(smoothSlider.value).toFixed(2));
dzSlider.addEventListener('input', ()=> dzV.textContent = Number(dzSlider.value).toFixed(1));

// Emit WS for aim (bridge)
function connectEmitWs(){
  if (emitWs && emitWs.readyState === WebSocket.OPEN) { emitWs.close(); return; }
  emitWs = new WebSocket('ws://localhost:8766');
  emitWs.onopen = ()=> appendConsole("Emit WS connected to ws://localhost:8766");
  emitWs.onclose = ()=> appendConsole("Emit WS closed");
  emitWs.onerror = ()=> appendConsole("Emit WS error");
}
emitWsChk.addEventListener('change', ()=> {
  if (emitWsChk.checked) connectEmitWs();
  else if (emitWs){ emitWs.close(); emitWs = null; }
});

// auto-connect emit if checked
if (emitWsChk.checked) connectEmitWs();

// expose a small API (for debug)
window._applyMapping = getMapping;

// initial UI info
appendConsole("UI ready. Load mapping and connect IMU (WebSocket or Serial).");

// end module
</script>
</body>
</html>
