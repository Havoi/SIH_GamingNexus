<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Cervical Granular Target (Advanced IMU Calibration)</title>
    <style>
      :root {
        --color-neon-cyan: #00ffff;
        --color-neon-magenta: #ff00ff;
        --color-neon-green: #00ff00;
        --color-neon-orange: #ffaa00;
        --color-dark-bg: #111827; /* Dark Slate */
        --color-mid-bg: #222d3b;
        --color-text-main: #f3f4f6;
      }
      body {
        margin: 0;
        overflow: hidden;
        background: var(--color-dark-bg);
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        color: var(--color-text-main);
      }
      #hud {
        position: absolute;
        top: 0;
        left: 0;
        padding: 15px 20px;
        background: rgba(0, 0, 0, 0.7);
        border-bottom: 2px solid var(--color-neon-cyan);
        box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        pointer-events: none;
        z-index: 10;
        /* Updated to match original Calibrator layout for HUD info */
        width: 300px;
        display: block;
      }
      .title {
        font-size: 1.4em;
        font-weight: 700;
        color: var(--color-neon-cyan);
        letter-spacing: 1px;
        margin-bottom: 10px;
      }
      .stat-row {
        display: flex;
        justify-content: space-between;
        font-size: 14px;
        margin-bottom: 4px;
        opacity: 0.8;
      }
      .val {
        color: var(--color-text-main);
        font-weight: bold;
      }
      #status {
        color: var(--color-neon-cyan);
        margin-bottom: 15px;
        font-size: 1.1em;
      }

      /* New Range Bar Styles from Calibrator */
      #range-bar-container {
        margin-top: 10px;
        border-top: 1px solid #333;
        padding-top: 10px;
      }
      .range-bar {
        height: 4px;
        background: #333;
        margin-bottom: 5px;
        position: relative;
      }
      .range-fill {
        height: 100%;
        background: var(--color-neon-green);
        position: absolute;
        width: 0%;
        left: 50%;
        transition: width 0.1s, left 0.1s;
      }

      #controls {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 15px;
        pointer-events: auto;
        z-index: 10;
        flex-wrap: wrap; /* Added for better layout */
        justify-content: center;
        width: 90%;
      }
      button {
        background: var(--color-mid-bg);
        color: var(--color-neon-cyan);
        border: 1px solid var(--color-neon-cyan);
        padding: 12px 10px;
        font-family: inherit;
        font-size: 13px;
        cursor: pointer;
        text-transform: uppercase;
        font-weight: bold;
        transition: 0.2s;
        box-shadow: 0 0 5px rgba(0, 255, 255, 0.3);
        border-radius: 6px;
        min-width: 150px;
      }
      button:hover {
        background: var(--color-neon-cyan);
        color: var(--color-dark-bg);
        box-shadow: 0 0 15px var(--color-neon-cyan);
      }
      button:disabled {
        border-color: #555;
        color: #555;
        background: #111;
        box-shadow: none;
        cursor: default;
      }
      .active-scan {
        background: var(--color-neon-magenta) !important;
        color: var(--color-dark-bg) !important;
        border-color: var(--color-neon-magenta) !important;
        box-shadow: 0 0 15px var(--color-neon-magenta) !important;
        animation: pulse 1s infinite;
      }
      @keyframes pulse {
        0% {
          opacity: 1;
        }
        50% {
          opacity: 0.7;
        }
        100% {
          opacity: 1;
        }
      }
      #file-input {
        display: none;
      }
    </style>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
        }
      }
    </script>
  </head>
  <body>
    <div id="hud">
      <div class="title">CERVICAL TARGET (ADVANCED CAL)</div>
      <div id="status">STATUS: DISCONNECTED</div>

      <div class="stat-row">
        <span>Yaw Axis:</span>
        <span id="val-yaw-axis" class="val">PENDING</span>
      </div>
      <div class="stat-row">
        <span>Pitch Axis:</span>
        <span id="val-pitch-axis" class="val">PENDING</span>
      </div>
      <div style="height: 10px"></div>
      <div class="stat-row">
        <span>Current Yaw:</span>
        <span id="val-curr-yaw" class="val">0.0°</span>
      </div>
      <div class="stat-row">
        <span>Current Pitch:</span>
        <span id="val-curr-pitch" class="val">0.0°</span>
      </div>

      <div id="range-bar-container">
        <div style="font-size: 11px; color: #aaa; margin-bottom: 2px">
          RECORDED RANGE (ROM)
        </div>
        <div class="stat-row">
          <span>Max Left:</span> <span id="val-min-yaw" class="val">0°</span>
        </div>
        <div class="range-bar"><div id="bar-yaw" class="range-fill"></div></div>
        <div class="stat-row">
          <span>Max Right:</span> <span id="val-max-yaw" class="val">0°</span>
        </div>

        <div style="height: 5px"></div>

        <div class="stat-row">
          <span>Max Up:</span> <span id="val-min-pitch" class="val">0°</span>
        </div>
        <div class="range-bar">
          <div id="bar-pitch" class="range-fill"></div>
        </div>
        <div class="stat-row">
          <span>Max Down:</span> <span id="val-max-pitch" class="val">0°</span>
        </div>
      </div>
    </div>

    <div id="controls">
      <button id="btn-connect">1. CONNECT SENSOR</button>
      <button id="btn-load-cal">LOAD CALIBRATION FILE</button>
      <input type="file" id="file-input" accept=".json" />
      <button id="btn-cal-yaw" disabled>2a. CALIBRATE YAW</button>
      <button id="btn-cal-pitch" disabled>2b. CALIBRATE PITCH</button>
      <button id="btn-cal-range" disabled>3. MEASURE RANGE</button>
      <button id="btn-save-cal" disabled>4. SAVE PROFILE</button>
      <button id="btn-recenter" disabled>RECENTER (SPACE)</button>
    </div>

    <script type="module">
      import * as THREE from "three";
      import * as CANNON from "cannon-es";

      // =========================================================
      // 1. THE ROBUST MATH ENGINE (Integrated from Advanced IMU Calibrator)
      // =========================================================
      class RobustSolver {
        constructor() {
          // Axes
          this.yawAxis = new THREE.Vector3(0, 1, 0);
          this.pitchAxis = new THREE.Vector3(1, 0, 0);
          this.axisSamples = [];
          this.isCalibratingAxes = false; // Renamed from isCalibrating

          // State
          this.tareQuat = new THREE.Quaternion();
          this.currentQuat = new THREE.Quaternion();

          // Settings
          this.pitchMultiplier = 1.0;
          this.yawMultiplier = 1.0;

          // Range Data (in Radians) - NEW
          this.range = {
            minYaw: -0.5, // Default ~28 degrees
            maxYaw: 0.5,
            minPitch: -0.5,
            maxPitch: 0.5,
          };
          this.isCalibratingRange = false; // NEW
        }

        // --- STREAM PROCESSING ---
        processStream(w, x, y, z) {
          this.currentQuat.set(x, y, z, w).normalize();
        }

        recenter() {
          this.tareQuat.copy(this.currentQuat);
        }

        // --- ANGLE CALCULATION ---
        getAngles() {
          const delta = new THREE.Quaternion()
            .copy(this.tareQuat)
            .invert()
            .multiply(this.currentQuat);
          const w = Math.max(-1, Math.min(1, delta.w));
          const angle = 2 * Math.acos(w);

          if (Math.abs(angle) < 0.001) return { yaw: 0, pitch: 0 };

          const s = Math.sqrt(1 - w * w);
          let axis = new THREE.Vector3(delta.x, delta.y, delta.z).divideScalar(
            s
          );

          const yawContribution = axis.dot(this.yawAxis);
          const pitchContribution = axis.dot(this.pitchAxis);

          let yaw = angle * yawContribution * this.yawMultiplier;
          let pitch = angle * pitchContribution * this.pitchMultiplier;

          // If measuring range, update limits - NEW
          if (this.isCalibratingRange) {
            if (yaw < this.range.minYaw) this.range.minYaw = yaw;
            if (yaw > this.range.maxYaw) this.range.maxYaw = yaw;
            if (pitch < this.range.minPitch) this.range.minPitch = pitch;
            if (pitch > this.range.maxPitch) this.range.maxPitch = pitch;
          }

          return { yaw, pitch };
        }

        // --- AXIS CALIBRATION ---
        startAxisScan() {
          this.axisSamples = [];
          this.isCalibratingAxes = true;
        }

        stopAxisScan() {
          this.isCalibratingAxes = false;
          if (this.axisSamples.length === 0) return new THREE.Vector3(0, 1, 0);
          let mean = new THREE.Vector3(0, 0, 0);
          for (let v of this.axisSamples) mean.add(v);
          mean.normalize();
          return mean;
        }

        sampleCalibrationFrame() {
          if (!this.isCalibratingAxes) return;
          const delta = new THREE.Quaternion()
            .copy(this.tareQuat)
            .invert()
            .multiply(this.currentQuat);
          const theta = 2 * Math.acos(delta.w);
          if (theta > 0.1) {
            const s = Math.sqrt(1 - delta.w * delta.w);
            if (s > 0.001) {
              const axis = new THREE.Vector3(
                delta.x / s,
                delta.y / s,
                delta.z / s
              );
              if (
                this.axisSamples.length > 0 &&
                axis.dot(this.axisSamples[0]) < 0
              )
                axis.negate();
              this.axisSamples.push(axis);
            }
          }
        }

        setAxes(yaw, pitch) {
          this.yawAxis.copy(yaw).normalize();
          this.pitchAxis.copy(pitch).normalize();
        }

        // --- RANGE CALIBRATION ---
        startRangeScan() {
          // NEW
          this.range = {
            minYaw: 0.1,
            maxYaw: -0.1,
            minPitch: 0.1,
            maxPitch: -0.1,
          };
          this.isCalibratingRange = true;
        }

        stopRangeScan() {
          // NEW
          this.isCalibratingRange = false;
          // Safety: Ensure min is actually less than max (in case user didn't move)
          if (this.range.minYaw > this.range.maxYaw) {
            this.range.minYaw = -0.5;
            this.range.maxYaw = 0.5;
          }
          if (this.range.minPitch > this.range.maxPitch) {
            this.range.minPitch = -0.5;
            this.range.maxPitch = 0.5;
          }
        }

        // --- LOAD/SAVE (Updated to include TareQuat and Range) ---
        loadProfile(json) {
          // Updated to load full profile
          if (json.tareQuat) {
            this.tareQuat
              .set(
                json.tareQuat.x,
                json.tareQuat.y,
                json.tareQuat.z,
                json.tareQuat.w
              )
              .normalize();
          }
          this.yawAxis
            .set(json.yawAxis.x, json.yawAxis.y, json.yawAxis.z)
            .normalize();
          this.pitchAxis
            .set(json.pitchAxis.x, json.pitchAxis.y, json.pitchAxis.z)
            .normalize();
          this.yawMultiplier = json.yawMultiplier || 1.0;
          this.pitchMultiplier = json.pitchMultiplier || 1.0;
          // Load Range if it exists, otherwise default
          if (json.range) this.range = json.range;

          // Also set the global captured axes for game state
          capturedYaw = this.yawAxis;
          capturedPitch = this.pitchAxis;
        }

        exportProfile() {
          // Updated to export full profile
          return {
            tareQuat: {
              x: this.tareQuat.x,
              y: this.tareQuat.y,
              z: this.tareQuat.z,
              w: this.tareQuat.w,
            },
            yawAxis: {
              x: this.yawAxis.x,
              y: this.yawAxis.y,
              z: this.yawAxis.z,
            },
            pitchAxis: {
              x: this.pitchAxis.x,
              y: this.pitchAxis.y,
              z: this.pitchAxis.z,
            },
            yawMultiplier: this.yawMultiplier,
            pitchMultiplier: this.pitchMultiplier,
            range: this.range, // EXPORT RANGE DATA
          };
        }
      }

      const solver = new RobustSolver();

      // =========================================================
      // 2. GAME ENGINE & TARGET LOGIC (Retained)
      // =========================================================
      // --- CONFIGURATION ---
      const RAD2DEG = 57.2958;
      const DEG_10_RAD = 0.1745;
      const ANGLE_TO_UNIT_FACTOR = 8.5;
      const HOLD_DURATION = 2.0;
      const DISTANCE_THRESHOLD = 0.8;

      const C_CYAN = 0x00ffff;
      const C_GREEN = 0x00ff00;
      const C_MAGENTA = 0xff00ff;
      const C_ORANGE = 0xffaa00;
      const C_WHITE = 0xffffff;

      function angleToPosition(angleRad) {
        return angleRad * ANGLE_TO_UNIT_FACTOR;
      }

      // Define target sequence for 10-degree increments (Retained)
      const TARGET_SEQUENCE_DEFINITION = [
        // ... (Target definitions as provided in the user's code) ...
        {
          angleYaw: DEG_10_RAD * 1,
          anglePitch: 0,
          color: C_GREEN,
          name: "+10° Right",
        },
        {
          angleYaw: DEG_10_RAD * 2,
          anglePitch: 0,
          color: C_GREEN,
          name: "+20° Right",
        },
        {
          angleYaw: DEG_10_RAD * 3,
          anglePitch: 0,
          color: C_GREEN,
          name: "+30° Right",
        },
        { angleYaw: 0, anglePitch: 0, color: C_WHITE, name: "CENTER (Reset)" },
        {
          angleYaw: -DEG_10_RAD * 1,
          anglePitch: 0,
          color: C_CYAN,
          name: "-10° Left",
        },
        {
          angleYaw: -DEG_10_RAD * 2,
          anglePitch: 0,
          color: C_CYAN,
          name: "-20° Left",
        },
        {
          angleYaw: -DEG_10_RAD * 3,
          anglePitch: 0,
          color: C_CYAN,
          name: "-30° Left",
        },
        { angleYaw: 0, anglePitch: 0, color: C_WHITE, name: "CENTER (Reset)" },
        {
          angleYaw: 0,
          anglePitch: -DEG_10_RAD * 1,
          color: C_MAGENTA,
          name: "-10° Up (Extension)",
        },
        {
          angleYaw: 0,
          anglePitch: -DEG_10_RAD * 2,
          color: C_MAGENTA,
          name: "-20° Up (Extension)",
        },
        {
          angleYaw: 0,
          anglePitch: -DEG_10_RAD * 3,
          color: C_MAGENTA,
          name: "-30° Up (Extension)",
        },
        { angleYaw: 0, anglePitch: 0, color: C_WHITE, name: "CENTER (Reset)" },
        {
          angleYaw: 0,
          anglePitch: DEG_10_RAD * 1,
          color: C_ORANGE,
          name: "+10° Down (Flexion)",
        },
        {
          angleYaw: 0,
          anglePitch: DEG_10_RAD * 2,
          color: C_ORANGE,
          name: "+20° Down (Flexion)",
        },
        {
          angleYaw: 0,
          anglePitch: DEG_10_RAD * 3,
          color: C_ORANGE,
          name: "+30° Down (Flexion)",
        },
        {
          angleYaw: 0,
          anglePitch: 0,
          color: C_WHITE,
          name: "CENTER (Final Reset)",
        },
      ];

      // --- THREE.js SETUP (Retained & Updated with Range Box) ---
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000a1a);
      const camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 0, 20);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
      directionalLight.position.set(5, 5, 5);
      scene.add(directionalLight);

      // Game Objects
      const userPointer = new THREE.Mesh(
        new THREE.SphereGeometry(0.5, 32, 32),
        new THREE.MeshLambertMaterial({ color: C_CYAN })
      );
      scene.add(userPointer);

      const targetRing = new THREE.Mesh(
        new THREE.RingGeometry(0.5, 0.7, 32),
        new THREE.MeshBasicMaterial({ color: C_WHITE, side: THREE.DoubleSide })
      );
      scene.add(targetRing);

      const centerDot = new THREE.Mesh(
        new THREE.SphereGeometry(0.1, 16, 16),
        new THREE.MeshBasicMaterial({ color: C_WHITE })
      );
      scene.add(centerDot);

      // The Range Box (New Visualization)
      const rangeBoxGeo = new THREE.BoxGeometry(1, 1, 1);
      const rangeBoxMat = new THREE.MeshBasicMaterial({
        color: 0xff0000,
        wireframe: true,
        transparent: true,
        opacity: 0.1,
      });
      const rangeBox = new THREE.Mesh(rangeBoxGeo, rangeBoxMat);
      rangeBox.renderOrder = -1; // Render behind everything
      scene.add(rangeBox);

      // --- GAME STATE ---
      let targetIndex = 0;
      let targetTimer = 0;
      let gameActive = false;
      let capturedYaw = null; // Stored axis vector
      let capturedPitch = null; // Stored axis vector

      function nextTarget() {
        if (targetIndex >= TARGET_SEQUENCE_DEFINITION.length) {
          gameActive = false;
          targetRing.visible = false;
          centerDot.material.color.setHex(C_GREEN);
          document.getElementById("status").innerText =
            "CALIBRATION/GAME COMPLETE!";
          return;
        }

        const target = TARGET_SEQUENCE_DEFINITION[targetIndex];
        const targetX = angleToPosition(target.angleYaw);
        const targetY = angleToPosition(target.anglePitch);

        targetRing.position.set(targetX, -targetY, 0);
        targetRing.material.color.setHex(target.color);
        centerDot.position.set(targetX, -targetY, 0);

        targetTimer = 0;
        document.getElementById("status").innerText = `TARGET: ${target.name}`;
      }

      // =========================================================
      // 3. UI & LOGIC (Updated for 3-step Calibration)
      // =========================================================
      let port,
        keepReading = false;

      function updateHUD(angles) {
        document.getElementById("val-curr-yaw").innerText =
          (angles.yaw * RAD2DEG).toFixed(1) + "°";
        document.getElementById("val-curr-pitch").innerText =
          (angles.pitch * RAD2DEG).toFixed(1) + "°";

        // Update Range Stats - NEW
        const r = solver.range;
        document.getElementById("val-min-yaw").innerText =
          (r.minYaw * RAD2DEG).toFixed(1) + "°";
        document.getElementById("val-max-yaw").innerText =
          (r.maxYaw * RAD2DEG).toFixed(1) + "°";
        document.getElementById("val-min-pitch").innerText =
          (r.minPitch * RAD2DEG).toFixed(1) + "°";
        document.getElementById("val-max-pitch").innerText =
          (r.maxPitch * RAD2DEG).toFixed(1) + "°";

        // Update Progress Bars - NEW
        const maxVisual = 60 * (Math.PI / 180); // ~60 degrees visual max

        const pPercent =
          Math.max(-1, Math.min(1, angles.pitch / maxVisual)) * 50;
        const pBar = document.getElementById("bar-pitch");
        pBar.style.left = 50 + Math.min(0, pPercent) + "%";
        pBar.style.width = Math.abs(pPercent) + "%";

        const yPercent = Math.max(-1, Math.min(1, angles.yaw / maxVisual)) * 50;
        const yBar = document.getElementById("bar-yaw");
        yBar.style.left = 50 + Math.min(0, yPercent) + "%";
        yBar.style.width = Math.abs(yPercent) + "%";
      }

      // --- BUTTON HANDLERS ---
      document.getElementById("btn-connect").onclick = async () => {
        try {
          // Check for Web Serial API support
          if (!("serial" in navigator)) {
            alert(
              "Web Serial API not supported in this browser. Please use Chrome/Edge."
            );
            return;
          }
          port = await navigator.serial.requestPort();
          await port.open({ baudRate: 115200 });
          keepReading = true;
          readLoop();
          document.getElementById("status").innerText =
            "STATUS: CONNECTED (Ready for Cal)";
          document.getElementById("btn-connect").disabled = true;
          document.getElementById("btn-cal-yaw").disabled = false;
        } catch (e) {
          alert("Connection Error: " + e);
          document.getElementById("status").innerText =
            "STATUS: CONNECTION FAILED";
        }
      };

      // 2a. CALIBRATE YAW
      const btnYaw = document.getElementById("btn-cal-yaw");
      btnYaw.onclick = () => {
        if (!solver.isCalibratingAxes) {
          solver.recenter();
          solver.startAxisScan();
          btnYaw.innerText = "Stop Scanning Yaw";
          btnYaw.classList.add("active-scan");
        } else {
          capturedYaw = solver.stopAxisScan();
          document.getElementById("val-yaw-axis").innerText = capturedYaw
            .toArray()
            .map((v) => v.toFixed(2))
            .join(", ");
          btnYaw.innerText = "Yaw Axis Set";
          btnYaw.classList.remove("active-scan");
          btnYaw.disabled = true;
          document.getElementById("btn-cal-pitch").disabled = false;
        }
      };

      // 2b. CALIBRATE PITCH
      const btnPitch = document.getElementById("btn-cal-pitch");
      btnPitch.onclick = () => {
        if (!solver.isCalibratingAxes) {
          solver.recenter();
          solver.startAxisScan();
          btnPitch.innerText = "Stop Scanning Pitch";
          btnPitch.classList.add("active-scan");
        } else {
          capturedPitch = solver.stopAxisScan();
          solver.setAxes(capturedYaw, capturedPitch);
          document.getElementById("val-pitch-axis").innerText = capturedPitch
            .toArray()
            .map((v) => v.toFixed(2))
            .join(", ");
          btnPitch.innerText = "Pitch Axis Set";
          btnPitch.classList.remove("active-scan");
          btnPitch.disabled = true;
          document.getElementById("btn-recenter").disabled = false;
          document.getElementById("btn-cal-range").disabled = false; // Next step
        }
      };

      // 3. MEASURE RANGE - NEW
      const btnRange = document.getElementById("btn-cal-range");
      btnRange.onclick = () => {
        if (!solver.isCalibratingRange) {
          solver.recenter(); // Zero out before measuring ROM
          solver.startRangeScan();
          btnRange.innerText = "MOVE TO LIMITS";
          btnRange.classList.add("active-scan");
          document.getElementById("status").innerText =
            "CALIBRATING RANGE: MOVE HEAD ALL DIRECTIONS";
          rangeBox.material.color.setHex(C_MAGENTA); // Visual cue
          rangeBox.material.opacity = 0.5;
        } else {
          solver.stopRangeScan();
          btnRange.innerText = "Range Saved";
          btnRange.classList.remove("active-scan");
          btnRange.disabled = true;
          document.getElementById("status").innerText =
            "CALIBRATION COMPLETE. Ready for Game.";
          document.getElementById("btn-save-cal").disabled = false;
          rangeBox.material.color.setHex(C_CYAN); // Change color back
          rangeBox.material.opacity = 0.2;

          // Optionally start the game after calibration
          // startGame();
        }
      };

      document.getElementById("btn-recenter").onclick = () => solver.recenter();
      window.addEventListener("keydown", (e) => {
        if (
          e.code === "Space" &&
          !document.getElementById("btn-recenter").disabled
        )
          solver.recenter();
      });

      // --- SAVE/LOAD ---
      const btnSave = document.getElementById("btn-save-cal");
      btnSave.onclick = () => {
        const profile = solver.exportProfile();
        if (!profile) return;
        const dataStr =
          "data:text/json;charset=utf-8," +
          encodeURIComponent(JSON.stringify(profile));
        const dlAnchor = document.createElement("a");
        dlAnchor.setAttribute("href", dataStr);
        dlAnchor.setAttribute("download", "imu_full_profile.json");
        dlAnchor.click();
        document.getElementById("status").innerText = "PROFILE SAVED.";
      };

      const btnLoad = document.getElementById("btn-load-cal");
      const fileInput = document.getElementById("file-input");
      btnLoad.onclick = () => fileInput.click();
      fileInput.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
          try {
            const data = JSON.parse(event.target.result);
            solver.loadProfile(data);
            document.getElementById("status").innerText =
              "PROFILE LOADED. Ready to Play/Recenter.";
            // Set UI state to post-calibration
            document.getElementById("btn-recenter").disabled = false;
            document.getElementById("btn-save-cal").disabled = false;
            document.getElementById("btn-cal-yaw").disabled = true;
            document.getElementById("btn-cal-pitch").disabled = true;
            document.getElementById("btn-cal-range").disabled = true;
            document.getElementById("val-yaw-axis").innerText = "LOADED";
            document.getElementById("val-pitch-axis").innerText = "LOADED";
            // Optionally start game upon load
            // startGame();
          } catch (error) {
            alert("Error loading calibration file: " + error.message);
          }
        };
        reader.readAsText(file);
      };

      // =========================================================
      // 4. ANIMATION LOOP
      // =========================================================
      let lastTime = performance.now();

      function animate() {
        requestAnimationFrame(animate);

        const currentTime = performance.now();
        const deltaTime = (currentTime - lastTime) / 1000;
        lastTime = currentTime;

        // 1. Process IMU data for calibration
        if (solver.isCalibratingAxes) solver.sampleCalibrationFrame();

        const angles = solver.getAngles();
        updateHUD(angles);

        // 2. Update User Pointer Position
        const userX = angleToPosition(angles.yaw);
        const userY = angleToPosition(angles.pitch);
        userPointer.position.set(userX, -userY, 0);

        // 3. Update Range Box Visualization - NEW
        const yawSpan = solver.range.maxYaw - solver.range.minYaw;
        const pitchSpan = solver.range.maxPitch - solver.range.minPitch;
        const yawCenter = (solver.range.maxYaw + solver.range.minYaw) / 2;
        const pitchCenter = (solver.range.maxPitch + solver.range.minPitch) / 2;

        const distance = 10; // Visualize box at Z=10
        const scaleFactor = ANGLE_TO_UNIT_FACTOR / (DEG_10_RAD * 3); // Scale factor to make it visible

        rangeBox.scale.set(
          Math.max(0.1, yawSpan * distance),
          Math.max(0.1, pitchSpan * distance),
          1
        );

        // Position the box based on the center of the recorded range
        rangeBox.position.x = angleToPosition(yawCenter);
        rangeBox.position.y = -angleToPosition(pitchCenter);
        rangeBox.position.z = -1; // Place slightly behind the target plane

        // 4. Game Logic (Only runs if game is active)
        if (gameActive) {
          const target = TARGET_SEQUENCE_DEFINITION[targetIndex];
          const targetX = angleToPosition(target.angleYaw);
          const targetY = angleToPosition(target.anglePitch);

          const distanceToTarget = Math.sqrt(
            Math.pow(userX - targetX, 2) + Math.pow(userY - targetY, 2)
          );

          if (distanceToTarget < DISTANCE_THRESHOLD) {
            targetTimer += deltaTime;
            targetRing.material.opacity =
              1.0 - (targetTimer / HOLD_DURATION) * 0.5; // Fade slightly
            userPointer.material.color.setHex(target.color);

            if (targetTimer >= HOLD_DURATION) {
              targetIndex++;
              nextTarget();
            }
          } else {
            targetTimer = Math.max(0, targetTimer - deltaTime * 2); // Decay faster
            targetRing.material.opacity = 1.0;
            userPointer.material.color.setHex(C_CYAN);
          }

          document.getElementById("debug").innerText = `Target: ${
            target.name
          } | Time Left: ${(HOLD_DURATION - targetTimer).toFixed(
            1
          )}s | Max Yaw: ${(solver.range.maxYaw * RAD2DEG).toFixed(1)}°`;
        } else {
          document.getElementById(
            "debug"
          ).innerText = `CALIBRATE or LOAD PROFILE to begin game.`;
        }

        renderer.render(scene, camera);
      }
      animate();

      // =========================================================
      // 5. SERIAL READER (Retained)
      // =========================================================
      async function readLoop() {
        // ... (Serial reading logic as provided in the user's Calibrator code) ...
        const textDecoder = new TextDecoderStream();
        port.readable.pipeTo(textDecoder.writable);
        const reader = textDecoder.readable.getReader();
        let buffer = "";
        while (keepReading) {
          try {
            const { value, done } = await reader.read();
            if (done) break;
            buffer += value;
            const lines = buffer.split("\n");
            buffer = lines.pop();
            for (const line of lines) {
              try {
                const json = JSON.parse(line.trim());
                if (json.type === "imu" && json.quat)
                  solver.processStream(...json.quat);
              } catch (e) {}
            }
          } catch (error) {
            break;
          }
        }
      }
      window.onresize = () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      };

      // Initial call to set up the game start state
      function startGame() {
        targetIndex = 0;
        gameActive = true;
        targetRing.visible = true;
        centerDot.material.color.setHex(C_WHITE);
        nextTarget();
      }

      // Add a Start Game button since we now have a calibration phase
      const btnStartGame = document.createElement("button");
      btnStartGame.innerText = "5. START GAME";
      btnStartGame.style.backgroundColor = "var(--color-neon-green)";
      btnStartGame.style.color = "var(--color-dark-bg)";
      btnStartGame.style.borderColor = "var(--color-neon-green)";
      btnStartGame.onclick = startGame;
      document.getElementById("controls").appendChild(btnStartGame);
    </script>
  </body>
</html>
