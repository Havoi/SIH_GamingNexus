<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Void Orbit - 360 Defense</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; cursor: crosshair; }
        #ui { position: absolute; top: 20px; width: 100%; text-align: center; pointer-events: none; font-family: 'Segoe UI', sans-serif; text-transform: uppercase; letter-spacing: 4px; color: #fff; mix-blend-mode: difference; }
        #score { font-size: 40px; font-weight: 900; }
        #health-bar { width: 300px; height: 4px; background: #333; margin: 10px auto; border-radius: 2px; }
        #health-fill { width: 100%; height: 100%; background: #00ffff; box-shadow: 0 0 10px #00ffff; transition: width 0.2s; }
        #game-over { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: white; background: rgba(0,0,0,0.9); padding: 40px; border: 1px solid #333; z-index: 10; }
        #start-screen { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: white; cursor: pointer; background: rgba(0,0,0,0.8); padding: 20px; border: 1px solid #00ffff; }
        button { background: transparent; border: 1px solid #ff3333; color: #ff3333; padding: 10px 20px; font-size: 1.2em; cursor: pointer; text-transform: uppercase; margin-top: 20px; }
        button:hover { background: #ff3333; color: white; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="ui">
        <div id="score">0</div>
        <div id="health-bar"><div id="health-fill"></div></div>
    </div>
    
    <div id="start-screen">
        <h1 style="color: #00ffff; text-shadow: 0 0 20px #00ffff;">VOID ORBIT</h1>
        <p>Defend the Core.</p>
        <p>Move Mouse to Orbit Shield.</p>
        <p>Bounce Enemies into each other.</p>
        <p style="font-size: 0.8em; color: #888;">(Click to Start)</p>
    </div>

    <div id="game-over">
        <h1 style="color: #ff3333">CORE BREACH</h1>
        <p>Final Score: <span id="final-score">0</span></p>
        <button id="restart-btn">Reboot System</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { AfterimagePass } from 'three/addons/postprocessing/AfterimagePass.js';

        // --- GAME CONFIG ---
        const CONFIG = {
            CORE_RADIUS: 2,
            SHIELD_RADIUS: 8,
            SHIELD_ARC: Math.PI / 3, // 60 degrees
            ENEMY_SPEED_BASE: 5,
            SPAWN_RATE_START: 1.5,
            MAX_HEALTH: 100
        };

        // --- AUDIO ENGINE (Web Audio API) ---
        class AudioEngine {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.3;
                this.masterGain.connect(this.ctx.destination);
                this.isPlaying = false;
            }

            resume() {
                if (this.ctx.state === 'suspended') this.ctx.resume();
                if (!this.isPlaying) {
                    this.startDrone();
                    this.isPlaying = true;
                }
            }

            startDrone() {
                // Deep thrumming bass drone
                const osc = this.ctx.createOscillator();
                osc.type = 'sawtooth';
                osc.frequency.value = 55; // Low A
                
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 150;

                const lfo = this.ctx.createOscillator();
                lfo.type = 'sine';
                lfo.frequency.value = 0.5; // Heartbeat pulse speed
                
                const lfoGain = this.ctx.createGain();
                lfoGain.gain.value = 50; // Filter modulation depth

                lfo.connect(lfoGain);
                lfoGain.connect(filter.frequency);
                
                osc.connect(filter);
                filter.connect(this.masterGain);
                
                osc.start();
                lfo.start();
                this.droneOsc = osc;
            }

            playDeflect() {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(880, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(2000, this.ctx.currentTime + 0.1);
                
                gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);

                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.2);
            }

            playExplosion() {
                const bufferSize = this.ctx.sampleRate * 0.5;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 1000;
                filter.frequency.linearRampToValueAtTime(100, this.ctx.currentTime + 0.4);

                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(1, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.4);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                noise.start();
            }

            playCoreHit() {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(100, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(30, this.ctx.currentTime + 0.3);
                
                gain.gain.setValueAtTime(0.8, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);

                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.3);
            }
        }

        // --- GAME STATE ---
        const state = {
            score: 0,
            health: CONFIG.MAX_HEALTH,
            gameOver: false,
            running: false,
            time: 0,
            mouseAngle: 0,
            spawnTimer: 0,
            difficultyMultiplier: 1
        };

        const audio = new AudioEngine();

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.02);

        // Orthographic Camera for Top-Down 2D gameplay in 3D space
        const frustumSize = 40;
        const aspect = window.innerWidth / window.innerHeight;
        const camera = new THREE.OrthographicCamera(
            frustumSize * aspect / -2, frustumSize * aspect / 2,
            frustumSize / 2, frustumSize / -2,
            1, 1000
        );
        camera.position.set(0, 20, 0);
        camera.lookAt(0, 0, 0);
        // Tilt slightly for depth
        camera.position.z = 10;
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.body.appendChild(renderer.domElement);

        // --- POST PROCESSING ---
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.1;
        bloomPass.strength = 2.5; // Intense Glow
        bloomPass.radius = 0.5;
        composer.addPass(bloomPass);

        const afterimagePass = new AfterimagePass();
        afterimagePass.uniforms['damp'].value = 0.7; // Trail strength
        composer.addPass(afterimagePass);

        // --- OBJECTS ---
        
        // 1. The Core
        const coreGeo = new THREE.IcosahedronGeometry(CONFIG.CORE_RADIUS, 1);
        const coreMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true });
        const coreInnerMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const core = new THREE.Group();
        
        const coreMesh = new THREE.Mesh(coreGeo, coreMat);
        const coreInner = new THREE.Mesh(new THREE.IcosahedronGeometry(CONFIG.CORE_RADIUS * 0.6, 0), coreInnerMat);
        
        core.add(coreMesh);
        core.add(coreInner);
        
        const coreLight = new THREE.PointLight(0x00ffff, 2, 50);
        core.add(coreLight);
        scene.add(core);

        // 2. The Shield
        const shieldGroup = new THREE.Group();
        const shieldGeo = new THREE.TorusGeometry(CONFIG.SHIELD_RADIUS, 0.3, 8, 30, CONFIG.SHIELD_ARC);
        const shieldMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
        const shieldMesh = new THREE.Mesh(shieldGeo, shieldMat);
        shieldMesh.rotation.x = Math.PI / 2; // Flat on plane
        shieldMesh.rotation.z = Math.PI; // Center the arc
        shieldGroup.add(shieldMesh);
        scene.add(shieldGroup);

        // 3. Starfield
        const starsGeo = new THREE.BufferGeometry();
        const starsCount = 1000;
        const posArray = new Float32Array(starsCount * 3);
        for(let i=0; i<starsCount*3; i++) {
            posArray[i] = (Math.random() - 0.5) * 100;
        }
        starsGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const starsMat = new THREE.PointsMaterial({ size: 0.1, color: 0x8888ff });
        const starMesh = new THREE.Points(starsGeo, starsMat);
        scene.add(starMesh);

        // --- GAMEPLAY ENTITIES ---
        const enemies = [];
        const particles = [];

        class Enemy {
            constructor() {
                this.mesh = new THREE.Mesh(
                    new THREE.TetrahedronGeometry(0.8),
                    new THREE.MeshBasicMaterial({ color: 0xff3333 })
                );
                
                // Spawn logic
                const angle = Math.random() * Math.PI * 2;
                const distance = 30; // Outside screen
                this.mesh.position.set(Math.cos(angle) * distance, 0, Math.sin(angle) * distance);
                
                this.velocity = new THREE.Vector3().subVectors(new THREE.Vector3(0,0,0), this.mesh.position).normalize().multiplyScalar(CONFIG.ENEMY_SPEED_BASE * state.difficultyMultiplier);
                
                this.mesh.lookAt(0,0,0);
                this.isNeutralized = false; // Is bouncing?
                this.active = true;

                scene.add(this.mesh);
            }

            update(dt) {
                this.mesh.position.addScaledVector(this.velocity, dt);
                this.mesh.rotation.x += dt * 2;
                this.mesh.rotation.y += dt * 2;

                // Collision with Core
                if (!this.isNeutralized && this.mesh.position.length() < CONFIG.CORE_RADIUS) {
                    this.active = false;
                    takeDamage(10);
                    createExplosion(this.mesh.position, 0xff0000);
                }

                // Cleanup if too far (after bounce)
                if (this.mesh.position.length() > 50) {
                    this.active = false;
                }
            }

            remove() {
                scene.remove(this.mesh);
            }
        }

        class Particle {
            constructor(pos, color) {
                this.mesh = new THREE.Mesh(
                    new THREE.BoxGeometry(0.2, 0.2, 0.2),
                    new THREE.MeshBasicMaterial({ color: color })
                );
                this.mesh.position.copy(pos);
                this.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 10,
                    0,
                    (Math.random() - 0.5) * 10
                );
                this.life = 1.0;
                scene.add(this.mesh);
            }
            update(dt) {
                this.life -= dt * 2;
                this.mesh.position.addScaledVector(this.velocity, dt);
                this.mesh.rotation.z += dt * 5;
                this.mesh.scale.setScalar(this.life);
            }
            remove() {
                scene.remove(this.mesh);
            }
        }

        function createExplosion(pos, color) {
            for(let i=0; i<10; i++) particles.push(new Particle(pos, color));
        }

        function takeDamage(amount) {
            state.health = Math.max(0, state.health - amount);
            document.getElementById('health-fill').style.width = state.health + '%';
            document.getElementById('health-fill').style.background = '#ff0000';
            setTimeout(() => {
                document.getElementById('health-fill').style.background = '#00ffff';
            }, 100);
            
            audio.playCoreHit();
            shakeIntensity = 0.5;

            if (state.health <= 0) gameOver();
        }

        function gameOver() {
            state.gameOver = true;
            document.getElementById('game-over').style.display = 'block';
            document.getElementById('final-score').innerText = state.score;
        }

        // --- INPUT ---
        document.addEventListener('mousemove', (e) => {
            if (!state.running || state.gameOver) return;
            const x = e.clientX - window.innerWidth / 2;
            const y = e.clientY - window.innerHeight / 2;
            // Calculate angle, standard Math.atan2 is (y, x). 
            // In 3D top-down (XZ plane), Z is "down" screen (y in 2D), X is Right.
            // Shield is rotated 180 (PI) in definition, so we adjust.
            state.mouseAngle = -Math.atan2(y, x); // Negative for correct clockwise/counter rotation mapping
        });

        document.getElementById('start-screen').addEventListener('click', () => {
            document.getElementById('start-screen').style.display = 'none';
            state.running = true;
            audio.resume();
            loop();
        });

        document.getElementById('restart-btn').addEventListener('click', () => {
            location.reload();
        });

        // --- PHYSICS & LOGIC ---
        let lastTime = 0;
        let shakeIntensity = 0;

        function updatePhysics(dt) {
            // Update Shield Position
            shieldGroup.rotation.y = state.mouseAngle + Math.PI / 2; // Offset for starting orientation

            // Difficulty ramping
            state.difficultyMultiplier += dt * 0.01;
            state.spawnTimer += dt;
            const currentSpawnRate = Math.max(0.3, CONFIG.SPAWN_RATE_START / (state.difficultyMultiplier * 0.8));

            if (state.spawnTimer > currentSpawnRate) {
                enemies.push(new Enemy());
                state.spawnTimer = 0;
            }

            // Update Entities
            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                e.update(dt);

                if (!e.active) {
                    e.remove();
                    enemies.splice(i, 1);
                    continue;
                }

                // Check Shield Collision
                // 1. Is it near the shield radius?
                const dist = e.mesh.position.length();
                if (!e.isNeutralized && Math.abs(dist - CONFIG.SHIELD_RADIUS) < 0.5) {
                    // 2. Is it within the arc angle?
                    const enemyAngle = Math.atan2(-e.mesh.position.z, e.mesh.position.x); // Matching mouse angle math
                    let angleDiff = enemyAngle - state.mouseAngle;
                    
                    // Normalize -PI to PI
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                    if (Math.abs(angleDiff) < CONFIG.SHIELD_ARC / 2) {
                        // REFLECT!
                        e.isNeutralized = true;
                        e.mesh.material.color.setHex(0xffffff); // White
                        
                        // Reflection math: Normal is vector from center to enemy
                        const normal = e.mesh.position.clone().normalize();
                        const v = e.velocity.clone();
                        // R = V - 2(V.N)N
                        const dot = v.dot(normal);
                        e.velocity.sub(normal.multiplyScalar(2 * dot));
                        e.velocity.multiplyScalar(1.2); // Speed up slightly on bounce
                        
                        audio.playDeflect();
                        shakeIntensity = 0.2;
                    }
                }
                
                // Check Combo (Neutralized hitting Hostile)
                if (e.isNeutralized) {
                    for (let j = 0; j < enemies.length; j++) {
                        if (i === j) continue;
                        const target = enemies[j];
                        if (!target.isNeutralized && target.mesh.position.distanceTo(e.mesh.position) < 1.5) {
                            // COMBO!
                            target.active = false;
                            e.active = false;
                            createExplosion(target.mesh.position, 0xffaa00);
                            audio.playExplosion();
                            state.score += 50 * Math.floor(state.difficultyMultiplier);
                            document.getElementById('score').innerText = state.score;
                            shakeIntensity = 0.8;
                        }
                    }
                }
            }

            // Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.update(dt);
                if (p.life <= 0) {
                    p.remove();
                    particles.splice(i, 1);
                }
            }
        }

        // --- RENDER LOOP ---
        function loop(time = 0) {
            requestAnimationFrame(loop);
            if (state.gameOver) return;

            const dt = Math.min((time - lastTime) / 1000, 0.1);
            lastTime = time;

            if (state.running) {
                updatePhysics(dt);

                // Animations
                core.scale.setScalar(1 + Math.sin(time * 0.005) * 0.1); // Pulse
                core.rotation.y += dt;
                core.rotation.z += dt * 0.5;
                starMesh.rotation.y += dt * 0.05;

                // Screen Shake
                if (shakeIntensity > 0) {
                    camera.position.x = (Math.random() - 0.5) * shakeIntensity;
                    camera.position.z = 10 + (Math.random() - 0.5) * shakeIntensity;
                    shakeIntensity = Math.max(0, shakeIntensity - dt * 2);
                } else {
                    camera.position.x = 0;
                    camera.position.z = 10;
                }
            }

            composer.render();
        }

        // Handle Resize
        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -frustumSize * aspect / 2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = -frustumSize / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>