<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Subterranean Explorer | Adjustable Speed</title>
    <style>
        body { margin: 0; background: #050505; overflow: hidden; font-family: 'Segoe UI', sans-serif; user-select: none; }

        /* UI OVERLAY */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }

        /* HEADER HUD */
        #hud-top {
            display: flex; justify-content: space-between; padding: 20px;
            background: linear-gradient(to bottom, rgba(0,255,255,0.1), transparent);
            color: #00ffff; text-shadow: 0 0 10px #00ffff;
        }
        .stat-box { min-width: 150px; }
        .stat-val { font-size: 32px; font-weight: bold; font-family: 'Courier New', monospace; }
        .stat-label { font-size: 12px; opacity: 0.8; letter-spacing: 2px; }

        /* CENTER RETICLE */
        #reticle {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 40px; height: 40px;
            border: 2px solid rgba(0, 255, 255, 0.3); border-radius: 50%;
            transition: all 0.1s; pointer-events: none;
        }
        #reticle.locking { border-color: #ff00ff; border-width: 4px; width: 60px; height: 60px; }
        #lock-bar {
            position: absolute; bottom: -20px; left: 50%; transform: translateX(-50%);
            width: 0%; height: 4px; background: #ff00ff; transition: width 0.1s;
        }

        /* MENUS */
        #menu-container {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 100%; display: flex; justify-content: center; pointer-events: auto; z-index: 10;
        }
        .panel {
            background: rgba(10, 20, 30, 0.95); border: 1px solid #00ffff; padding: 40px;
            border-radius: 10px; box-shadow: 0 0 30px rgba(0, 255, 255, 0.2);
            text-align: center; color: white; max-width: 500px; display: none;
        }
        .panel.active { display: block; }
        h1 { margin: 0 0 10px 0; color: #00ffff; font-family: 'Courier New', monospace; letter-spacing: 4px; }
        p { color: #aaa; margin-bottom: 30px; }

        /* BUTTONS */
        button {
            background: rgba(0, 255, 255, 0.1); color: #00ffff; border: 1px solid #00ffff;
            padding: 15px 30px; font-size: 16px; font-weight: bold; cursor: pointer;
            text-transform: uppercase; margin: 10px; transition: 0.2s; font-family: 'Courier New';
        }
        button:hover { background: #00ffff; color: black; box-shadow: 0 0 20px #00ffff; }
        button:disabled { border-color: #555; color: #555; background: transparent; cursor: default; box-shadow: none; }

        /* CONTROLS BAR (Bottom) */
        #controls-bar {
            padding: 20px; background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);
            pointer-events: auto; color: white; display: flex; gap: 20px; align-items: flex-end;
        }
        
        .control-group { display: flex; flex-direction: column; gap: 5px; }
        label { font-size: 10px; color: #00ffff; font-family: 'Courier New'; }
        input[type="range"] { accent-color: #00ffff; cursor: pointer; width: 100px; }

        .toggle-btn { padding: 8px 12px; font-size: 12px; margin: 0; }
        .toggle-btn.active { background: #00ffff; color: black; }
        .toggle-btn.inverted { background: #ff0055; border-color: #ff0055; color: white; }

        /* SATURATION BARS */
        .sat-wrapper { width: 100px; margin-right: 20px; border-right: 1px solid #333; padding-right: 20px; }
        .sat-track { width: 100%; height: 6px; background: #222; margin-top: 4px; position: relative; }
        .sat-fill { width: 0%; height: 100%; background: #ff00ff; position: absolute; left: 50%; transition: width 0.05s, left 0.05s; }

        input[type="file"] { display: none; }
    </style>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>
</head>
<body>

<div id="game-container"></div>

<div id="ui-layer">
    <div id="hud-top">
        <div>
            <div class="stat-label">SCORE</div>
            <div class="stat-val" id="score-val">0</div>
        </div>
        <div style="text-align: right;">
            <div class="stat-label">SYSTEM STATUS</div>
            <div class="stat-val" id="status-text" style="font-size: 18px; color: #ff00ff;">OFFLINE</div>
        </div>
    </div>

    <div id="reticle">
        <div id="lock-bar"></div>
    </div>

    <div id="menu-container">
        <div id="screen-connect" class="panel active">
            <h1>SUBTERRANEAN EXPLORER</h1>
            <p>Connect IMU to Initialize Rail System</p>
            <button id="btn-connect">Connect Sensor</button>
        </div>

        <div id="screen-load" class="panel">
            <h1>LOAD CONFIGURATION</h1>
            <p>Load Range Calibration Profile</p>
            <button id="btn-load">Select JSON</button>
            <input type="file" id="file-input" accept=".json">
        </div>

        <div id="screen-ready" class="panel">
            <h1>SYSTEMS READY</h1>
            <p>Look at targets to lock on.<br>Stay within your calibrated range.</p>
            <button id="btn-start">INITIATE DIVE</button>
        </div>
    </div>

    <div id="controls-bar">
        <div class="sat-wrapper">
            <label>RANGE (YAW)</label>
            <div class="sat-track"><div id="sat-yaw" class="sat-fill"></div></div>
            <div style="height: 5px;"></div>
            <label>RANGE (PITCH)</label>
            <div class="sat-track"><div id="sat-pitch" class="sat-fill"></div></div>
        </div>

        <div class="control-group">
            <label>SPEED: <span id="val-speed">0.1</span></label>
            <input type="range" id="input-speed" min="0.0" max="1.0" step="0.05" value="0.1">
        </div>
        <div class="control-group">
            <label>SENSITIVITY: <span id="val-sens">1.0</span></label>
            <input type="range" id="input-sens" min="0.5" max="3.0" step="0.1" value="1.0">
        </div>
        <div class="control-group">
            <label>SMOOTHING: <span id="val-smooth">0.15</span></label>
            <input type="range" id="input-smooth" min="0.01" max="0.5" step="0.01" value="0.15">
        </div>

        <div class="control-group" style="flex-direction: row; gap: 5px;">
            <button id="btn-inv-yaw" class="toggle-btn active">Yaw: Norm</button>
            <button id="btn-inv-pitch" class="toggle-btn active">Pitch: Norm</button>
        </div>

        <button id="btn-recenter" style="margin-left: auto;">Recenter (R)</button>
    </div>
</div>

<script type="module">
import * as THREE from 'three';

// GAME SETTINGS
const MAX_CAM_YAW = 50 * (Math.PI / 180);   
const MAX_CAM_PITCH = 35 * (Math.PI / 180); 
const LOCK_TIME = 40; 

// =========================================================
// 1. RANGE ADAPTIVE SOLVER
// =========================================================
class RangeAdaptiveSolver {
    constructor() {
        this.yawAxis = new THREE.Vector3(0, 1, 0);
        this.pitchAxis = new THREE.Vector3(1, 0, 0);
        this.baseYawMult = 1.0;
        this.basePitchMult = 1.0;
        this.userYawInv = 1.0;
        this.userPitchInv = 1.0;
        
        this.sensitivity = 1.0;
        this.smoothing = 0.15; 

        this.range = { minYaw: -0.5, maxYaw: 0.5, minPitch: -0.5, maxPitch: 0.5 };
        
        this.tareQuat = new THREE.Quaternion();
        this.currentQuat = new THREE.Quaternion(); 
        this.targetQuat = new THREE.Quaternion(); 
        this.saturation = { yaw: 0, pitch: 0 }; 
    }

    loadProfile(json) {
        this.yawAxis.set(json.yawAxis.x, json.yawAxis.y, json.yawAxis.z);
        this.pitchAxis.set(json.pitchAxis.x, json.pitchAxis.y, json.pitchAxis.z);
        this.baseYawMult = json.yawMultiplier || 1.0;
        this.basePitchMult = json.pitchMultiplier || 1.0;
        if (json.range) this.range = json.range;
    }
    
    toggleYaw() { this.userYawInv *= -1; return this.userYawInv === 1; }
    togglePitch() { this.userPitchInv *= -1; return this.userPitchInv === 1; }

    updateRaw(w, x, y, z) {
        this.targetQuat.set(x, y, z, w).normalize();
    }
    
    updateSmoothing() {
        this.currentQuat.slerp(this.targetQuat, this.smoothing);
    }

    recenter() {
        this.tareQuat.copy(this.currentQuat);
    }

    getInput() {
        const delta = new THREE.Quaternion().copy(this.tareQuat).invert().multiply(this.currentQuat);
        const w = Math.max(-1, Math.min(1, delta.w));
        const angle = 2 * Math.acos(w);
        
        if (Math.abs(angle) < 0.0001) return { yaw: 0, pitch: 0 };

        const s = Math.sqrt(1 - w*w);
        const axis = new THREE.Vector3(delta.x, delta.y, delta.z).divideScalar(s);
        
        let rawYaw = angle * axis.dot(this.yawAxis) * this.baseYawMult * this.userYawInv;
        let rawPitch = angle * axis.dot(this.pitchAxis) * this.basePitchMult * this.userPitchInv;

        let normYaw = this.mapRange(rawYaw, this.range.minYaw, this.range.maxYaw, -1, 1);
        let normPitch = this.mapRange(rawPitch, this.range.minPitch, this.range.maxPitch, -1, 1);

        this.saturation.yaw = normYaw;
        this.saturation.pitch = normPitch;

        return {
            yaw: -normYaw * this.sensitivity, 
            pitch: normPitch * this.sensitivity
        };
    }

    mapRange(val, inMin, inMax, outMin, outMax) {
        const clampedVal = Math.max(inMin, Math.min(val, inMax));
        return (clampedVal - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
    }
}

const solver = new RangeAdaptiveSolver();

// =========================================================
// 2. THREE.JS WORLD
// =========================================================
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);
scene.fog = new THREE.FogExp2(0x000000, 0.02);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 200);
camera.position.set(0, 0, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.getElementById('game-container').appendChild(renderer.domElement);

const camLight = new THREE.PointLight(0x00ffff, 1, 50);
camera.add(camLight);
scene.add(camera);

// TUNNEL GENERATION
const tunnelSegments = [];
const SEGMENT_COUNT = 16; // More segments for smoother slow speed
const SEGMENT_LENGTH = 10;

const tunGeo = new THREE.CylinderGeometry(8, 8, SEGMENT_LENGTH, 16, 1, true);
const tunMat = new THREE.MeshBasicMaterial({ 
    color: 0x004444, wireframe: true, transparent: true, opacity: 0.3 
});

for(let i=0; i<SEGMENT_COUNT; i++) {
    const seg = new THREE.Mesh(tunGeo, tunMat);
    seg.rotation.x = -Math.PI / 2;
    seg.position.z = -i * SEGMENT_LENGTH;
    scene.add(seg);
    tunnelSegments.push(seg);
}

// TARGETS
const targets = [];
const targetGeo = new THREE.IcosahedronGeometry(0.8, 0);
const targetMat = new THREE.MeshBasicMaterial({ color: 0xff0055, wireframe: true });

function spawnTarget() {
    const mesh = new THREE.Mesh(targetGeo, targetMat.clone());
    const angle = Math.random() * Math.PI * 2;
    const radius = 2 + Math.random() * 4;
    mesh.position.set(
        Math.cos(angle) * radius,
        Math.sin(angle) * radius,
        camera.position.z - 80 
    );
    const glow = new THREE.PointLight(0xff0055, 1, 5);
    mesh.add(glow);
    
    scene.add(mesh);
    targets.push({ mesh: mesh, active: true, lockTimer: 0 });
}

// PARTICLES
const particles = [];
function explode(pos) {
    for(let i=0; i<10; i++) {
        const pGeo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
        const pMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
        const p = new THREE.Mesh(pGeo, pMat);
        p.position.copy(pos);
        p.userData.vel = new THREE.Vector3((Math.random()-0.5), (Math.random()-0.5), (Math.random()-0.5));
        scene.add(p);
        particles.push(p);
    }
}

// =========================================================
// 3. GAME LOGIC
// =========================================================
let gameState = "SETUP";
let score = 0;
// --- SPEED CONFIGURATION ---
let baseSpeed = 0.1; // Default start speed (Very slow)
let currentSpeed = 0.1; 

const raycaster = new THREE.Raycaster();
const center = new THREE.Vector2(0, 0);

// UI Elements
const barSatYaw = document.getElementById('sat-yaw');
const barSatPitch = document.getElementById('sat-pitch');
const reticle = document.getElementById('reticle');
const lockBar = document.getElementById('lock-bar');

function updateGameLogic() {
    if (gameState !== "PLAYING") return;

    // 1. Move Camera (Rail Movement)
    camera.position.z -= currentSpeed;

    // 2. Infinite Tunnel
    tunnelSegments.forEach(seg => {
        if(seg.position.z > camera.position.z + SEGMENT_LENGTH) {
            seg.position.z -= SEGMENT_COUNT * SEGMENT_LENGTH;
        }
    });

    // 3. Handle Input (Look)
    const input = solver.getInput();
    
    const targetYaw = input.yaw * MAX_CAM_YAW;
    const targetPitch = input.pitch * MAX_CAM_PITCH;

    const euler = new THREE.Euler(targetPitch, targetYaw, 0, 'YXZ');
    camera.quaternion.setFromEuler(euler);

    // 4. Update UI Bars
    const yawP = solver.saturation.yaw * 50; 
    const pitP = solver.saturation.pitch * 50;
    
    barSatYaw.style.left = (50 + Math.min(0, yawP)) + "%";
    barSatYaw.style.width = Math.abs(yawP) + "%";
    barSatPitch.style.left = (50 + Math.min(0, pitP)) + "%";
    barSatPitch.style.width = Math.abs(pitP) + "%";

    // 5. Targets & Locking
    if(Math.random() < 0.015) spawnTarget(); // Reduced spawn rate

    raycaster.setFromCamera(center, camera);
    const intersectObjects = targets.map(t => t.mesh);
    const intersects = raycaster.intersectObjects(intersectObjects);

    let locking = false;

    if (intersects.length > 0) {
        const hitObj = intersects[0].object;
        const targetData = targets.find(t => t.mesh === hitObj);
        
        if (targetData && targetData.active) {
            locking = true;
            targetData.lockTimer++;
            
            lockBar.style.width = (targetData.lockTimer / LOCK_TIME * 100) + "%";
            
            if (targetData.lockTimer > LOCK_TIME) {
                // DESTROY
                score += 100;
                document.getElementById('score-val').innerText = score;
                explode(targetData.mesh.position);
                scene.remove(targetData.mesh);
                targetData.active = false;
                lockBar.style.width = "0%";
                
                // Gentler Difficulty Increase
                if (currentSpeed < 1.0) { // Cap max speed
                    baseSpeed += 0.005; // Very slow acceleration
                }
            }
        }
    }

    if (!locking) {
        lockBar.style.width = "0%";
        targets.forEach(t => t.lockTimer = Math.max(0, t.lockTimer - 2)); 
    }

    reticle.classList.toggle('locking', locking);

    // Cleanup Targets
    for (let i = targets.length - 1; i >= 0; i--) {
        const t = targets[i];
        if (!t.active) {
            targets.splice(i, 1);
            continue;
        }
        if (t.mesh.position.z > camera.position.z + 5) {
            scene.remove(t.mesh);
            targets.splice(i, 1);
        }
    }

    // Update Particles
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.position.add(p.userData.vel);
        p.scale.multiplyScalar(0.9);
        if(p.scale.x < 0.01) {
            scene.remove(p);
            particles.splice(i, 1);
        }
    }
}

function animate() {
    requestAnimationFrame(animate);
    solver.updateSmoothing();
    updateGameLogic();
    renderer.render(scene, camera);
}
animate();

// =========================================================
// 4. UI HANDLERS
// =========================================================
let port, keepReading = false;
const screens = ['screen-connect', 'screen-load', 'screen-ready'];

function switchScreen(id) {
    screens.forEach(s => document.getElementById(s).classList.remove('active'));
    document.getElementById(id).classList.add('active');
}

// CONNECT
document.getElementById('btn-connect').onclick = async () => {
    try {
        port = await navigator.serial.requestPort();
        await port.open({ baudRate: 115200 });
        keepReading = true;
        readLoop();
        document.getElementById('status-text').innerText = "CONNECTED";
        document.getElementById('status-text').style.color = "#00ffff";
        switchScreen('screen-load');
    } catch (e) { alert("Connection Error"); }
};

// LOAD
document.getElementById('btn-load').onclick = () => document.getElementById('file-input').click();
document.getElementById('file-input').onchange = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (evt) => {
        try {
            solver.loadProfile(JSON.parse(evt.target.result));
            switchScreen('screen-ready');
        } catch (err) { alert("Invalid File"); }
    };
    reader.readAsText(file);
};

// START
document.getElementById('btn-start').onclick = () => {
    solver.recenter();
    document.getElementById('menu-container').style.display = "none";
    gameState = "PLAYING";
    document.getElementById('status-text').innerText = "ONLINE";
};

// CONTROLS
const btnInvYaw = document.getElementById('btn-inv-yaw');
const btnInvPitch = document.getElementById('btn-inv-pitch');

btnInvYaw.onclick = () => {
    const norm = solver.toggleYaw();
    btnInvYaw.innerText = norm ? "Yaw: Norm" : "Yaw: INV";
    btnInvYaw.className = norm ? "toggle-btn active" : "toggle-btn inverted";
};
btnInvPitch.onclick = () => {
    const norm = solver.togglePitch();
    btnInvPitch.innerText = norm ? "Pitch: Norm" : "Pitch: INV";
    btnInvPitch.className = norm ? "toggle-btn active" : "toggle-btn inverted";
};

document.getElementById('input-sens').oninput = (e) => {
    solver.sensitivity = parseFloat(e.target.value);
    document.getElementById('val-sens').innerText = solver.sensitivity.toFixed(1);
};
document.getElementById('input-smooth').oninput = (e) => {
    solver.smoothing = parseFloat(e.target.value);
    document.getElementById('val-smooth').innerText = solver.smoothing.toFixed(2);
};
document.getElementById('input-speed').oninput = (e) => {
    currentSpeed = parseFloat(e.target.value);
    document.getElementById('val-speed').innerText = currentSpeed.toFixed(2);
};

const doRecenter = () => solver.recenter();
document.getElementById('btn-recenter').onclick = doRecenter;
window.addEventListener('keydown', (e) => {
    if(e.code === 'Space') doRecenter();
    if(e.code === 'KeyR') doRecenter();
    if(e.code === 'Escape') {
        const m = document.getElementById('menu-container');
        m.style.display = (m.style.display === 'none') ? 'flex' : 'none';
    }
});

async function readLoop() {
    const textDecoder = new TextDecoderStream();
    port.readable.pipeTo(textDecoder.writable);
    const reader = textDecoder.readable.getReader();
    let buffer = "";
    while (keepReading) {
        const { value, done } = await reader.read();
        if (done) break;
        buffer += value;
        const lines = buffer.split('\n');
        buffer = lines.pop();
        for (const line of lines) {
            try {
                const json = JSON.parse(line);
                if (json.type === "imu" && json.quat) solver.updateRaw(...json.quat);
            } catch (e) {}
        }
    }
}
window.onresize = () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
};
</script>
</body>
</html>