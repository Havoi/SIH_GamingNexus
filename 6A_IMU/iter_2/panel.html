<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>IMU Control Panel — Quaternion Viewer (Revamp)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{
    --bg:#071427;
    --panel:#0f1720;
    --muted:#94a3b8;
    --accent:#78a1ff;
    --card:#071022;
    --log-bg:#020617;
    --good:#86efac;
    --bad:#fca5a5;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;color:#e6eef6;background:linear-gradient(180deg,#041022 0%, #071427 100%);}
  #app{display:flex; height:100vh; gap:12px; padding:12px; box-sizing:border-box;}
  #left{width:420px; min-width:340px; background:var(--panel); border-radius:10px; padding:14px; box-sizing:border-box; display:flex; flex-direction:column; gap:12px; border:1px solid rgba(255,255,255,0.03);}
  h1{margin:0;font-size:18px;font-weight:700;letter-spacing:0.2px;}
  .muted{color:var(--muted); font-size:13px;}
  .row{display:flex; gap:8px; align-items:center;}
  .btn{background:#0f2230;color:#e6eef6;border:1px solid #12303f;padding:8px 10px;border-radius:8px;cursor:pointer;font-weight:600;}
  .btn:active{transform:translateY(1px);}
  button.full{width:100%;}
  input[type=range]{width:100%;}
  #log{background:var(--log-bg); color:#9cc3ff; padding:8px; height:140px; overflow:auto; border-radius:8px; border:1px solid #0f2740; font-family:monospace; font-size:12px; white-space:pre-wrap;}
  .teleGrid{display:grid; grid-template-columns:1fr 1fr; gap:8px;}
  .teleBox{background:var(--card); border:1px solid #12303f; padding:10px; border-radius:8px; font-family:monospace; font-size:13px;}
  label{font-size:13px;color:#cbd5e1;}
  .controlGrid{display:grid; grid-template-columns:1fr 1fr; gap:8px;}
  .small{font-size:13px;color:var(--muted);}
  .footer{margin-top:auto;font-size:12px;color:var(--muted);}
  #visualCard{flex:1;background:linear-gradient(180deg,#071427 0%, #051024 100%);border-radius:10px;padding:10px; display:flex; flex-direction:column; gap:10px; border:1px solid rgba(255,255,255,0.03);}
  #visual{flex:1;border-radius:8px; overflow:hidden; position:relative; background:transparent;}
  #hud{display:flex; gap:8px; align-items:center;}
  .chip{background:rgba(255,255,255,0.02); padding:6px 8px; border-radius:8px; border:1px solid rgba(255,255,255,0.02); font-weight:600;}
  #graphs{display:flex; gap:8px; align-items:center;}
  canvas.graph{background:rgba(0,0,0,0.12); border-radius:6px; border:1px solid rgba(255,255,255,0.03);}
  /* virtual cursor */
  #virtual-cursor{position:fixed; left:50%; top:50%; width:14px; height:14px; margin-left:-7px; margin-top:-7px; border-radius:50%; background: rgba(255,255,255,0.95); box-shadow:0 0 10px rgba(255,255,255,0.1); pointer-events:none; z-index:9999; transform:translate(-50%,-50%); display:none;}
  /* axis mapping control compact */
  .mapRow{display:flex; gap:8px; align-items:center; flex-wrap:wrap;}
  select, input[type=text]{background:#071022;color:#e6eef6;border:1px solid #12303f;padding:6px;border-radius:6px;}
  .smallmuted{font-size:12px;color:#9fb3d6;}
  .toggle{display:inline-flex; align-items:center; gap:6px;}
</style>
</head>
<body>
  <div id="app">
    <div id="left">
      <div>
        <h1>IMU Control Panel — Quaternion Viewer</h1>
        <div class="muted">Nano R4 → MPU6050. Expected JSON: <code>{"q":[x,y,z,w],"t":...}</code></div>
      </div>

      <div class="row">
        <button id="btnConnect" class="btn">Connect</button>
        <button id="btnDisconnect" class="btn" disabled>Disconnect</button>
        <div style="flex:1"></div>
        <div id="connectState" class="chip">Disconnected</div>
      </div>

      <div style="display:flex; gap:8px;">
        <button id="btnCalGyro" class="btn">CAL_GYRO</button>
        <button id="btnSave" class="btn">SAVE</button>
        <button id="btnLoad" class="btn">LOAD</button>
      </div>

      <div class="controlGrid">
        <div>
          <label>Sample Rate (Hz) <span id="srVal">100</span></label>
          <input id="inpFreq" type="range" min="10" max="400" step="1" value="100">
          <div style="display:flex; gap:8px; margin-top:6px;">
            <button id="btnSetFreq" class="btn">SET_FREQ</button>
            <input id="freqBox" type="text" style="width:80px;" value="100">
          </div>
        </div>
        <div>
          <label>Madgwick β <span id="betaVal">0.100</span></label>
          <input id="inpBeta" type="range" min="0" max="1" step="0.001" value="0.1">
          <div style="display:flex; gap:8px; margin-top:6px;">
            <button id="btnSetBeta" class="btn">SET_BETA</button>
            <input id="betaBox" type="text" style="width:80px;" value="0.1">
          </div>
        </div>
      </div>

      <div style="display:flex; gap:8px;">
        <button id="btnInfo" class="btn">INFO</button>
        <button id="btnResetBias" class="btn">RESET_BIAS</button>
        <button id="btnCalMagDisabled" class="btn" disabled>CAL_MAG (N/A)</button>
      </div>

      <div class="teleGrid">
        <div class="teleBox" id="quatBox">q: —</div>
        <div class="teleBox" id="eulerBox">Euler: —</div>
        <div class="teleBox">t: <span id="tBox">—</span></div>
        <div class="teleBox">freq: <span id="measFreq">—</span> Hz</div>
      </div>

      <!-- Axis Mapping Controls -->
      <div style="padding:8px; border-radius:8px; background:rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.02);">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <div style="font-weight:700">Axis Mapping & Mouse</div>
          <div class="smallmuted">Map sensor → cube</div>
        </div>

        <div class="mapRow" style="margin-top:8px;">
          <label>Cube X:
            <select id="mapX">
              <option value="roll">roll</option><option value="pitch">pitch</option><option value="yaw">yaw</option><option value="none">none</option>
            </select>
          </label>
          <label>Cube Y:
            <select id="mapY">
              <option value="pitch">pitch</option><option value="roll">roll</option><option value="yaw">yaw</option><option value="none">none</option>
            </select>
          </label>
          <label>Cube Z:
            <select id="mapZ">
              <option value="yaw">yaw</option><option value="roll">roll</option><option value="pitch">pitch</option><option value="none">none</option>
            </select>
          </label>
        </div>

        <div class="mapRow" style="margin-top:8px;">
          <label>Invert X <input type="checkbox" id="invX"></label>
          <label>Invert Y <input type="checkbox" id="invY"></label>
          <label>Invert Z <input type="checkbox" id="invZ"></label>

          <label style="margin-left:auto;">Sensitivity
            <input id="sensitivity" type="range" min="0.2" max="3" step="0.1" value="1" style="width:120px;">
          </label>
          <label>Smoothing
            <input id="smoothing" type="range" min="0" max="0.98" step="0.01" value="0.85" style="width:120px;">
          </label>
        </div>

        <div class="mapRow" style="margin-top:8px;">
          <label class="toggle"><input type="checkbox" id="virtualCursorToggle"> Page Cursor</label>
          <label class="toggle"><input type="checkbox" id="quatOrderToggle"> MCU q order is [w,x,y,z]</label>
          <button id="resetAxisMapping" class="btn" style="margin-left:auto;">Reset</button>
          <!-- Calibrations & rotation offsets -->
<div class="mapRow" style="margin-top:8px; gap:6px; align-items:center;">
  <button id="btnCalGlobal" class="btn">Cal Global Axis</button>
  <button id="btnResetGlobal" class="btn">Reset Global Cal</button>

  <div style="margin-left:8px; display:flex; gap:6px; align-items:center; flex-wrap:wrap;">
    <div class="smallmuted" style="margin-right:6px;">Rotate frame:</div>
    <button id="rotXpos" class="btn">X +90</button>
    <button id="rotXneg" class="btn">X -90</button>
    <button id="rotYpos" class="btn">Y +90</button>
    <button id="rotYneg" class="btn">Y -90</button>
    <button id="rotZpos" class="btn">Z +90</button>
    <button id="rotZneg" class="btn">Z -90</button>
  </div>
</div>

        </div>
        <div class="smallmuted" style="margin-top:6px;">Virtual cursor controls a page-level cursor. Use Sensitivity & Smoothing to tune response. Toggle quaternion order if your MCU sends w-first.</div>
      </div>

      <div>
        <div style="margin:6px 0; color:var(--muted);">Serial Log</div>
        <div id="log"></div>
      </div>

      <div class="footer">Open in Chrome/Edge (secure context). Use Connect to pick the Nano's port. I can add OS-cursor bridge if you want.</div>
    </div>

    <div id="visualCard">
      <div id="hud">
        <div class="chip" id="staleChip">No Data</div>
        <div style="flex:1"></div>
        <div class="chip" id="latChip">lat: — ms</div>
        <div class="chip" id="magChip">Δq: —</div>
      </div>

      <div id="visual"></div>

      <div id="graphs">
        <canvas id="freqGraph" class="graph" width="300" height="80"></canvas>
        <canvas id="deltaGraph" class="graph" width="300" height="80"></canvas>
      </div>
    </div>
  </div>

  <div id="virtual-cursor"></div>

<script type="module">
/* Complete script: IMU Control Panel
   - Robust serial connect/disconnect
   - Quaternion normalization
   - Euler unwrap smoothing (fix roll jump)
   - Axis mapping + invert + sensitivity + smoothing
   - Global axis calibration + rotation offsets
   - Virtual page cursor (in-browser)
   - Tiny realtime graphs
*/

import * as THREE from 'https://unpkg.com/three@0.154.0/build/three.module.js';

/* -------------------
   DOM bindings
------------------- */
const logEl = document.getElementById('log');
const btnConnect = document.getElementById('btnConnect');
const btnDisconnect = document.getElementById('btnDisconnect');
const btnCalGyro = document.getElementById('btnCalGyro');
const btnSave = document.getElementById('btnSave');
const btnLoad = document.getElementById('btnLoad');
const btnInfo = document.getElementById('btnInfo');
const btnResetBias = document.getElementById('btnResetBias');

const inpFreq = document.getElementById('inpFreq');
const srVal = document.getElementById('srVal');
const btnSetFreq = document.getElementById('btnSetFreq');
const freqBox = document.getElementById('freqBox');

const inpBeta = document.getElementById('inpBeta');
const betaVal = document.getElementById('betaVal');
const btnSetBeta = document.getElementById('btnSetBeta');
const betaBox = document.getElementById('betaBox');

const quatBox = document.getElementById('quatBox');
const eulerBox = document.getElementById('eulerBox');
const tBox = document.getElementById('tBox');
const measFreq = document.getElementById('measFreq');
const connectState = document.getElementById('connectState');
const staleChip = document.getElementById('staleChip');
const latChip = document.getElementById('latChip');
const magChip = document.getElementById('magChip');

const mapX = document.getElementById('mapX');
const mapY = document.getElementById('mapY');
const mapZ = document.getElementById('mapZ');
const invX = document.getElementById('invX');
const invY = document.getElementById('invY');
const invZ = document.getElementById('invZ');
const sensSlider = document.getElementById('sensitivity');
const smoothSlider = document.getElementById('smoothing');
const virtualCursorToggle = document.getElementById('virtualCursorToggle');
const resetAxisMapping = document.getElementById('resetAxisMapping');
const quatOrderToggle = document.getElementById('quatOrderToggle');

const virtualCursor = document.getElementById('virtual-cursor');

const btnCalGlobal = document.getElementById('btnCalGlobal');
const btnResetGlobal = document.getElementById('btnResetGlobal');
const rotXpos = document.getElementById('rotXpos');
const rotXneg = document.getElementById('rotXneg');
const rotYpos = document.getElementById('rotYpos');
const rotYneg = document.getElementById('rotYneg');
const rotZpos = document.getElementById('rotZpos');
const rotZneg = document.getElementById('rotZneg');

/* -------------------
   Internal state
------------------- */
let port = null, reader = null, writer = null;
let keepReading = false;
let inputDone = null, outputDone = null;
let lastJSONTime = 0;
let lastFrameTime = performance.now();
let frameCount = 0;
let measuredHz = 0;
let lastAppliedEuler = null; // radians {roll,pitch,yaw}
let lastAppliedQuat = null; // normalized quaternion applied to cube
let lastRawQuat = null; // last incoming normalized quaternion for delta
let lastDeltaMag = 0;

// Calibration & mounting offsets
let globalCalQuat = null;      // THREE.Quaternion inverse baseline
let offsetQuat = new THREE.Quaternion(); // cumulative mounting offset (pre-multiply)

/* -------------------
   Graphing utils
------------------- */
const freqCanvas = document.getElementById('freqGraph');
const dfreq = freqCanvas.getContext('2d');
const deltaCanvas = document.getElementById('deltaGraph');
const ddelta = deltaCanvas.getContext('2d');

function clearGraph(ctx, w, h){
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle='rgba(255,255,255,0.02)'; ctx.fillRect(0,0,w,h);
}
function drawLine(ctx, data, opts){
  const w = ctx.canvas.width, h = ctx.canvas.height;
  clearGraph(ctx,w,h);
  if (!data || data.length===0) return;
  const maxVal = opts.max || Math.max(...data, 1e-6);
  ctx.beginPath();
  for (let i=0;i<data.length;i++){
    const x = (i / (data.length-1)) * w;
    const y = h - (data[i]/maxVal) * h;
    if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.strokeStyle = opts.color || '#78a1ff';
  ctx.lineWidth = 2;
  ctx.stroke();
}

/* Circular ring buffer */
function RingBuffer(size){
  this.size = size; this.buf = new Array(size).fill(0); this.i=0; this.filled=false;
}
RingBuffer.prototype.push = function(v){ this.buf[this.i++] = v; if (this.i>=this.size){ this.i=0; this.filled=true; } }
RingBuffer.prototype.array = function(){ return this.filled ? this.buf.slice(this.i).concat(this.buf.slice(0,this.i)) : this.buf.slice(0,this.i); }

const freqBuf = new RingBuffer(120);
const deltaBuf = new RingBuffer(120);

/* -------------------
   THREE.js scene
------------------- */
const visual = document.getElementById('visual');
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x071427);
const camera = new THREE.PerspectiveCamera(60, visual.clientWidth / visual.clientHeight, 0.1, 1000);
camera.position.set(2.2, 2.0, 3.5);
const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
renderer.setSize(visual.clientWidth, visual.clientHeight);
visual.appendChild(renderer.domElement);
window.addEventListener('resize', ()=>{ renderer.setSize(visual.clientWidth, visual.clientHeight); camera.aspect = visual.clientWidth / visual.clientHeight; camera.updateProjectionMatrix(); });

// camera orbit
let isPointerDown=false, lastX=0, lastY=0, yaw=0, pitch=-0.4;
renderer.domElement.addEventListener('pointerdown', (e)=>{ isPointerDown=true; lastX=e.clientX; lastY=e.clientY; renderer.domElement.setPointerCapture(e.pointerId); });
renderer.domElement.addEventListener('pointerup', (e)=>{ isPointerDown=false; try{ renderer.domElement.releasePointerCapture(e.pointerId); }catch{} });
renderer.domElement.addEventListener('pointermove', (e)=>{ if(!isPointerDown) return; let dx=(e.clientX-lastX)/200; let dy=(e.clientY-lastY)/200; yaw += dx; pitch += dy; lastX=e.clientX; lastY=e.clientY; });

// geometry
const axes = new THREE.AxesHelper(1.6); scene.add(axes);
const geo = new THREE.BoxGeometry(1.0, 0.6, 1.6);
const mat = new THREE.MeshStandardMaterial({ color:0x78a1ff, metalness:0.2, roughness:0.35 });
const cube = new THREE.Mesh(geo, mat); scene.add(cube);
const arrowX = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(0,0,0), 0.7, 0xff6b6b);
const arrowY = new THREE.ArrowHelper(new THREE.Vector3(0,1,0), new THREE.Vector3(0,0,0), 0.7, 0x6bff9b);
const arrowZ = new THREE.ArrowHelper(new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,0), 0.7, 0x6bb6ff);
cube.add(arrowX); cube.add(arrowY); cube.add(arrowZ);

const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.9); scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 0.8); dir.position.set(5,5,5); scene.add(dir);
const grid = new THREE.GridHelper(8, 16, 0x1b3c44, 0x0b2230); scene.add(grid);

function animate(){
  requestAnimationFrame(animate);
  camera.position.x = Math.cos(yaw) * 4;
  camera.position.z = Math.sin(yaw) * 4;
  camera.position.y = 2.2 + Math.sin(pitch) * 0.6;
  camera.lookAt(0,0,0);
  renderer.render(scene, camera);
}
animate();

/* -------------------
   Serial helpers & robust connect/disconnect
------------------- */
function appendLog(s){
  const time = new Date().toLocaleTimeString();
  logEl.textContent += `[${time}] ${s}\n`;
  if (logEl.textContent.length > 60000) logEl.textContent = logEl.textContent.slice(-40000);
  logEl.scrollTop = logEl.scrollHeight;
}

// Robust connect: tries to clean stale state and retry open if necessary
async function connectSerial(){
  btnConnect.disabled = true;
  try {
    // cleanup previous references
    if (port){
      try { keepReading = false; if (reader) { await reader.cancel(); reader = null; } } catch(e){ appendLog('cleanup reader: '+e); }
      try { if (writer) { await writer.close(); writer = null; } } catch(e){ appendLog('cleanup writer: '+e); }
      try { if (port && port.readable) await port.close(); } catch(e){ /* ignore */ }
      port = null;
    }

    port = await navigator.serial.requestPort();

    try {
      await port.open({ baudRate: 115200 });
    } catch (openErr) {
      appendLog('Open error: ' + openErr + ' — attempting close+retry');
      try { await port.close().catch(()=>{}); } catch(e){}
      await new Promise(r=>setTimeout(r,120));
      await port.open({ baudRate: 115200 });
    }

    connectState.textContent = 'Connected'; connectState.style.color = '#86efac';
    btnConnect.disabled = true; btnDisconnect.disabled = false;

    // writer
    const textEncoder = new TextEncoderStream();
    outputDone = textEncoder.readable.pipeTo(port.writable).catch(e => { appendLog("output stream pipeTo error: " + e); });
    writer = textEncoder.writable.getWriter();

    // reader
    const textDecoder = new TextDecoderStream();
    inputDone = port.readable.pipeTo(textDecoder.writable).catch(e => { appendLog("input stream pipeTo error: " + e); });
    reader = textDecoder.readable.pipeThrough(new TransformStream(new LineBreakTransformer())).getReader();

    keepReading = true;
    readLoop();
    appendLog("Serial connected.");
  } catch (err) {
    appendLog("Connect error: " + err);
    try { if (writer) { await writer.close(); writer = null; } } catch(e){}
    try { if (reader) { await reader.cancel(); reader = null; } } catch(e){}
    try { if (port) { await port.close().catch(()=>{}); } } catch(e){}
    port = null;
    btnConnect.disabled = false; btnDisconnect.disabled = true;
    connectState.textContent = 'Disconnected'; connectState.style.color = '#fca5a5';
  }
}

async function disconnectSerial(){
  keepReading = false;
  try { if (reader) { await reader.cancel(); } } catch(e){ appendLog('reader cancel err: '+e); }
  reader = null;
  try { if (inputDone) { await inputDone.catch(()=>{}); inputDone = null; } } catch(e){}
  try { if (writer) { await writer.close(); } } catch(e){ appendLog('writer close err: '+e); }
  writer = null;
  try { if (outputDone) { await outputDone.catch(()=>{}); outputDone = null; } } catch(e){}
  try { if (port) { await port.close(); } } catch(e){ appendLog('port close err: '+e); }
  port = null;

  // reset local state
  reader = null; writer = null; inputDone = null; outputDone = null; port = null;
  connectState.textContent = 'Disconnected'; connectState.style.color = '#fca5a5';
  btnConnect.disabled = false; btnDisconnect.disabled = true;
  appendLog("Serial disconnected.");
}

async function sendCmdLine(line){
  if (!writer){ appendLog("Not connected"); return; }
  await writer.write(line + "\n");
  appendLog("-> " + line);
}

async function readLoop(){
  if (!reader) return;
  try {
    while (keepReading) {
      const { value, done } = await reader.read();
      if (done) break;
      if (value) handleLine(value);
    }
  } catch (e) {
    appendLog("Read loop error: " + e);
  } finally {
    keepReading = false;
    if (reader) { try { await reader.cancel(); } catch{} reader = null; }
    if (writer) { try { await writer.close(); } catch{} writer = null; }
    if (port) { try { await port.close(); } catch{} port = null; }
    connectState.textContent = 'Disconnected'; connectState.style.color = '#fca5a5';
    btnConnect.disabled = false; btnDisconnect.disabled = true;
    appendLog("Read loop ended.");
  }
}

// LineBreak transformer for text stream
class LineBreakTransformer {
  constructor(){ this.container = ''; }
  transform(chunk, controller){ this.container += chunk; const lines = this.container.split(/\r?\n/); this.container = lines.pop(); lines.forEach(l => controller.enqueue(l)); }
  flush(controller){ if (this.container) controller.enqueue(this.container); }
}

/* -------------------
   Quaternion handling & mapping
------------------- */
function isFiniteNumber(n){ return typeof n === 'number' && isFinite(n); }
function normalize(q){ const mag = Math.hypot(q.x,q.y,q.z,q.w); if (!isFiniteNumber(mag) || mag < 1e-12) return {x:0,y:0,z:0,w:1}; return {x:q.x/mag, y:q.y/mag, z:q.z/mag, w:q.w/mag}; }
function quatToEuler(q){ const quat = new THREE.Quaternion(q.x,q.y,q.z,q.w); const e = new THREE.Euler().setFromQuaternion(quat, 'ZYX'); return { roll: e.x, pitch: e.y, yaw: e.z }; }
function applyDeadzone(v,dz){ if (Math.abs(v) < dz) return 0; return v; }

// Helper: unwrap angle to nearest neighbor relative to prev
function unwrapAngle(prev, curr){
  let d = curr - prev;
  if (d > Math.PI) curr -= 2 * Math.PI;
  else if (d < -Math.PI) curr += 2 * Math.PI;
  while (curr - prev > Math.PI) curr -= 2 * Math.PI;
  while (curr - prev < -Math.PI) curr += 2 * Math.PI;
  return curr;
}
function wrapToPi(a){ while (a > Math.PI) a -= 2 * Math.PI; while (a <= -Math.PI) a += 2 * Math.PI; return a; }

/* Calibration and mounting offsets */
function makeInverseQuaternion(qobj){ const q = new THREE.Quaternion(qobj.x, qobj.y, qobj.z, qobj.w).normalize(); return q.clone().invert(); }
function calibrateGlobalAxis(){ if (!lastRawQuat) { appendLog('No quaternion yet to calibrate from.'); return; } globalCalQuat = makeInverseQuaternion(lastRawQuat); appendLog('Global axis calibrated.'); }
function resetGlobalCal(){ globalCalQuat = null; appendLog('Global axis reset.'); }
function applyRotationOffset(axis, deg){ const rad = THREE.MathUtils.degToRad(deg); let e; if (axis==='X') e = new THREE.Euler(rad,0,0,'ZYX'); else if (axis==='Y') e = new THREE.Euler(0,rad,0,'ZYX'); else e = new THREE.Euler(0,0,rad,'ZYX'); const qrot = new THREE.Quaternion().setFromEuler(e); offsetQuat = qrot.clone().multiply(offsetQuat).normalize(); appendLog(`Applied offset ${axis} ${deg}°`); }
function resetRotationOffset(){ offsetQuat = new THREE.Quaternion(); appendLog('Rotation offsets reset.'); }

/* Main processing pipeline */
function processIncomingQuaternion(rawQobj, timestamp){
  // rawQobj {x,y,z,w} (not necessarily normalized)
  let qnorm = normalize(rawQobj);

  // build THREE quaternion
  let curQ = new THREE.Quaternion(qnorm.x, qnorm.y, qnorm.z, qnorm.w).normalize();

  // apply global calibration (if set): q_rel = globalCalQuat * curQ
  if (globalCalQuat) curQ = globalCalQuat.clone().multiply(curQ).normalize();

  // apply mounting offset: q_mapped = offsetQuat * curQ
  if (offsetQuat) curQ = offsetQuat.clone().multiply(curQ).normalize();

  // now produce new qnorm from corrected quaternion
  qnorm = { x: curQ.x, y: curQ.y, z: curQ.z, w: curQ.w };

  // compute Euler
  const e = quatToEuler(qnorm); // radians

  // mapping & UI controls
  const smoothing = Number(smoothSlider.value); // 0..0.98
  const sens = Number(sensSlider.value);
  const mapping = { X: mapX.value, Y: mapY.value, Z: mapZ.value };
  const inv = { X: invX.checked ? -1 : 1, Y: invY.checked ? -1 : 1, Z: invZ.checked ? -1 : 1 };

  // Build mapped Euler (radians)
  const mapped = {
    x: (mapping.X==='roll' ? e.roll : (mapping.X==='pitch' ? e.pitch : (mapping.X==='yaw' ? e.yaw : (lastAppliedEuler?lastAppliedEuler.roll:0)))),
    y: (mapping.Y==='roll' ? e.roll : (mapping.Y==='pitch' ? e.pitch : (mapping.Y==='yaw' ? e.yaw : (lastAppliedEuler?lastAppliedEuler.pitch:0)))),
    z: (mapping.Z==='roll' ? e.roll : (mapping.Z==='pitch' ? e.pitch : (mapping.Z==='yaw' ? e.yaw : (lastAppliedEuler?lastAppliedEuler.yaw:0))))
  };

  // apply invert & sensitivity & deadzone
  const deadzoneRad = THREE.MathUtils.degToRad(1.5);
  mapped.x = applyDeadzone(mapped.x, deadzoneRad) * inv.X * sens;
  mapped.y = applyDeadzone(mapped.y, deadzoneRad) * inv.Y * sens;
  mapped.z = applyDeadzone(mapped.z, deadzoneRad) * inv.Z * sens;

  // unwrap relative to lastAppliedEuler to avoid ±180 jumps
  if (!lastAppliedEuler) lastAppliedEuler = { roll: mapped.x, pitch: mapped.y, yaw: mapped.z };
  const mappedUnwrapped = {
    x: unwrapAngle(lastAppliedEuler.roll, mapped.x),
    y: unwrapAngle(lastAppliedEuler.pitch, mapped.y),
    z: unwrapAngle(lastAppliedEuler.yaw, mapped.z)
  };

  // smoothing - lerp using unwrapped
  const blended = {
    x: THREE.MathUtils.lerp(lastAppliedEuler.roll, mappedUnwrapped.x, 1 - smoothing),
    y: THREE.MathUtils.lerp(lastAppliedEuler.pitch, mappedUnwrapped.y, 1 - smoothing),
    z: THREE.MathUtils.lerp(lastAppliedEuler.yaw, mappedUnwrapped.z, 1 - smoothing)
  };

  // wrap blended values to [-PI,PI] for readability
  blended.x = wrapToPi(blended.x);
  blended.y = wrapToPi(blended.y);
  blended.z = wrapToPi(blended.z);

  // Create target quaternion from blended Euler (ZYX)
  const targetQuat = new THREE.Quaternion().setFromEuler(new THREE.Euler(blended.x, blended.y, blended.z, 'ZYX'));
  cube.quaternion.copy(targetQuat);

  // update last states
  lastAppliedEuler = { roll: blended.x, pitch: blended.y, yaw: blended.z };
  lastAppliedQuat = { x: targetQuat.x, y: targetQuat.y, z: targetQuat.z, w: targetQuat.w };

  // update UI text using qnorm (post-calibration/mapping)
  quatBox.textContent = `q: [${qnorm.x.toFixed(6)}, ${qnorm.y.toFixed(6)}, ${qnorm.z.toFixed(6)}, ${qnorm.w.toFixed(6)}]`;
  eulerBox.textContent = `Yaw:${THREE.MathUtils.radToDeg(blended.z).toFixed(1)}° Pitch:${THREE.MathUtils.radToDeg(blended.y).toFixed(1)}° Roll:${THREE.MathUtils.radToDeg(blended.x).toFixed(1)}°`;
  if (timestamp !== undefined) tBox.textContent = timestamp;

  // compute delta magnitude between lastRawQuat and current qnorm
  if (lastRawQuat){
    const dx = qnorm.x - lastRawQuat.x, dy = qnorm.y - lastRawQuat.y, dz = qnorm.z - lastRawQuat.z, dw = qnorm.w - lastRawQuat.w;
    const dmag = Math.hypot(dx,dy,dz,dw);
    lastDeltaMag = dmag;
    magChip.textContent = `Δq: ${dmag.toFixed(6)}`;
    deltaBuf.push(dmag);
  } else {
    deltaBuf.push(0);
  }
  lastRawQuat = qnorm;
}

/* -------------------
   Incoming line handling
------------------- */
function handleLine(line){
  line = line.trim();
  if (!line) return;
  try {
    const obj = JSON.parse(line);
    if (obj.q && Array.isArray(obj.q) && obj.q.length >= 4){
      let arr = obj.q.map(Number);
      if (!arr.every(isFinite)) { appendLog('Bad numeric quaternion, ignored'); return; }
      let q;
      if (quatOrderToggle.checked){
        // MCU sent [w,x,y,z]
        q = { x: arr[1], y: arr[2], z: arr[3], w: arr[0] };
      } else {
        // default [x,y,z,w]
        q = { x: arr[0], y: arr[1], z: arr[2], w: arr[3] };
      }
      processIncomingQuaternion(q, obj.t);
      // frequency measurement
      frameCount++;
      const now = performance.now();
      if (now - lastFrameTime >= 1000){
        measuredHz = frameCount * 1000 / (now - lastFrameTime);
        measFreq.textContent = measuredHz.toFixed(1);
        freqBuf.push(measuredHz);
        frameCount = 0; lastFrameTime = now;
      }
      lastJSONTime = Date.now();
      return;
    }
  } catch(e){
    // not JSON
  }
  appendLog(line);
}

/* -------------------
   Stale indicator & latency
------------------- */
setInterval(()=>{
  const now = Date.now();
  const dt = lastJSONTime ? now - lastJSONTime : Infinity;
  if (!lastJSONTime || dt > 600){
    staleChip.textContent = 'Stale / No Data'; staleChip.style.color = '#fca5a5';
  } else {
    staleChip.textContent = 'Live'; staleChip.style.color = '#86efac';
  }
  const tVal = parseInt(tBox.textContent);
  if (!Number.isNaN(tVal)){
    let tms = tVal;
    // heuristic: if micros, convert
    if (tVal > 1e12) tms = Math.floor(tVal / 1000);
    const lat = Date.now() - tms;
    latChip.textContent = 'lat: ' + lat + ' ms';
  } else {
    latChip.textContent = 'lat: — ms';
  }
}, 200);

/* -------------------
   Virtual cursor update
------------------- */
function pageSize(){ return { w: Math.max(document.documentElement.clientWidth, window.innerWidth || 0), h: Math.max(document.documentElement.clientHeight, window.innerHeight || 0) }; }
function updateVirtualCursorFromEuler(euler){
  const roll = euler.roll, pitch = euler.pitch, yaw = euler.yaw;
  const nx = Math.tanh(roll);
  const ny = Math.tanh(pitch);
  const ps = pageSize();
  const x = (ps.w/2) + nx * (ps.w/2) * 0.9;
  const y = (ps.h/2) - ny * (ps.h/2) * 0.9;
  if (virtualCursorToggle.checked){
    virtualCursor.style.display = 'block';
    virtualCursor.style.left = x + 'px';
    virtualCursor.style.top = y + 'px';
    const scale = 1 + Math.min(0.6, Math.abs(yaw)/1.6);
    virtualCursor.style.width = (14*scale) + 'px'; virtualCursor.style.height = (14*scale) + 'px';
    virtualCursor.style.marginLeft = -(7*scale) + 'px'; virtualCursor.style.marginTop = -(7*scale) + 'px';
  } else {
    virtualCursor.style.display = 'none';
  }
}

/* -------------------
   Graph updater
------------------- */
setInterval(()=>{
  drawLine(dfreq, freqBuf.array(), { color:'#78a1ff', max: Math.max(20, ...freqBuf.array()) });
  drawLine(ddelta, deltaBuf.array(), { color:'#ffd166', max: Math.max(0.001, ...deltaBuf.array()) });
}, 120);

/* -------------------
   UI wiring & events
------------------- */
btnConnect.addEventListener('click', async ()=>{ await connectSerial(); });
btnDisconnect.addEventListener('click', async ()=>{ await disconnectSerial(); });

btnCalGyro.addEventListener('click', ()=> sendCmdLine('CAL_GYRO'));
btnSave.addEventListener('click', ()=> sendCmdLine('SAVE'));
btnLoad.addEventListener('click', ()=> sendCmdLine('LOAD'));
btnInfo.addEventListener('click', ()=> sendCmdLine('INFO'));
btnResetBias.addEventListener('click', ()=> sendCmdLine('RESET_BIAS'));

inpFreq.addEventListener('input', ()=> { srVal.textContent = inpFreq.value; freqBox.value = inpFreq.value; });
btnSetFreq.addEventListener('click', ()=> { const v = freqBox.value; sendCmdLine('SET_FREQ:' + v); inpFreq.value = v; srVal.textContent = v; });

inpBeta.addEventListener('input', ()=> { betaVal.textContent = Number(inpBeta.value).toFixed(3); betaBox.value = Number(inpBeta.value).toFixed(3); });
btnSetBeta.addEventListener('click', ()=> { const v = betaBox.value; sendCmdLine('SET_BETA:' + v); inpBeta.value = v; betaVal.textContent = Number(v).toFixed(3); });

freqBox.addEventListener('change', ()=> { inpFreq.value = freqBox.value; srVal.textContent = freqBox.value; });
betaBox.addEventListener('change', ()=> { inpBeta.value = betaBox.value; betaVal.textContent = Number(betaBox.value).toFixed(3); });

window.addEventListener('keydown', (e)=>{ if (e.key === 'c' || e.key === 'C') btnConnect.click(); if (e.key === 'd' || e.key === 'D') btnDisconnect.click(); });

resetAxisMapping.addEventListener('click', ()=>{ mapX.value='roll'; mapY.value='pitch'; mapZ.value='yaw'; invX.checked = invY.checked = invZ.checked = false; sensSlider.value = 1; smoothSlider.value = 0.85; });

btnCalGlobal.addEventListener('click', ()=> calibrateGlobalAxis());
btnResetGlobal.addEventListener('click', ()=> { resetGlobalCal(); resetRotationOffset(); });
rotXpos.addEventListener('click', ()=> applyRotationOffset('X', 90));
rotXneg.addEventListener('click', ()=> applyRotationOffset('X', -90));
rotYpos.addEventListener('click', ()=> applyRotationOffset('Y', 90));
rotYneg.addEventListener('click', ()=> applyRotationOffset('Y', -90));
rotZpos.addEventListener('click', ()=> applyRotationOffset('Z', 90));
rotZneg.addEventListener('click', ()=> applyRotationOffset('Z', -90));

appendLog('UI ready. Click Connect to pick the Nano serial port.');

// expose for debug
window._processIncomingQuaternion = processIncomingQuaternion;

/* -------------------
   Lightweight update loop for virtual cursor
------------------- */
function updateLoop(){
  requestAnimationFrame(updateLoop);
  if (lastAppliedEuler && virtualCursorToggle.checked) updateVirtualCursorFromEuler(lastAppliedEuler);
}
updateLoop();

</script>

</body>
</html>
