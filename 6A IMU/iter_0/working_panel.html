<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>IMU Control Panel — Quaternion Viewer</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body { margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial; display:flex; height:100vh; }
  #left { width:390px; min-width:320px; background:#0f1720; color:#e6eef6; padding:14px; box-sizing:border-box; display:flex; flex-direction:column; gap:12px; }
  h1 { margin:0; font-size:18px; font-weight:600; }
  .btn { background:#1f2937; color:#e6eef6; border:1px solid #334155; padding:8px 10px; border-radius:6px; cursor:pointer; }
  .btn:active { transform:translateY(1px); }
  .row { display:flex; gap:8px; align-items:center; }
  .small { font-size:13px; color:#94a3b8; }
  #log { background:#020617; color:#9cc3ff; padding:8px; height:160px; overflow:auto; border-radius:6px; border:1px solid #102230; font-family:monospace; font-size:12px; }
  label { font-size:13px; color:#cbd5e1; }
  input[type=range] { width:100%; }
  #connectState { font-weight:700; color:#86efac; }
  #visual { flex:1; background:#0b1220; display:flex; align-items:center; justify-content:center; }
  #telemetry { display:grid; grid-template-columns:1fr 1fr; gap:6px; }
  .teleBox { background:#071022; border:1px solid #12303f; padding:8px; border-radius:6px; font-family:monospace; font-size:13px; }
  .controlGrid { display:grid; grid-template-columns:1fr 1fr; gap:8px; }
  button.full { width:100%; }
  .footer { margin-top:auto; font-size:12px; color:#94a3b8; }
  a.link { color:#93c5fd; text-decoration:none; }
</style>
</head>
<body>
  <div id="left">
    <div>
      <h1>IMU Control Panel</h1>
      <div class="small">Nano R4 → MPU6050 (A4/A5). Serial JSON: <code>{"q":[x,y,z,w],"t":...}</code></div>
    </div>

    <div class="row">
      <button id="btnConnect" class="btn">Connect</button>
      <button id="btnDisconnect" class="btn" disabled>Disconnect</button>
      <div style="flex:1"></div>
      <div id="connectState" class="small">Disconnected</div>
    </div>

    <div style="display:flex; gap:8px;">
      <button id="btnCalGyro" class="btn">CAL_GYRO</button>
      <button id="btnSave" class="btn">SAVE</button>
      <button id="btnLoad" class="btn">LOAD</button>
    </div>

    <div class="controlGrid">
      <div>
        <label>Sample Rate (Hz) <span id="srVal">100</span></label>
        <input id="inpFreq" type="range" min="10" max="400" step="1" value="100">
        <div style="display:flex; gap:8px; margin-top:6px;">
          <button id="btnSetFreq" class="btn">SET_FREQ</button>
          <input id="freqBox" style="width:80px; padding:6px; border-radius:6px; border:1px solid #213244; background:#071022; color:#e6eef6;" value="100">
        </div>
      </div>
      <div>
        <label>Madgwick β <span id="betaVal">0.100</span></label>
        <input id="inpBeta" type="range" min="0" max="1" step="0.001" value="0.1">
        <div style="display:flex; gap:8px; margin-top:6px;">
          <button id="btnSetBeta" class="btn">SET_BETA</button>
          <input id="betaBox" style="width:80px; padding:6px; border-radius:6px; border:1px solid #213244; background:#071022; color:#e6eef6;" value="0.1">
        </div>
      </div>
    </div>

    <div style="display:flex; gap:8px;">
      <button id="btnInfo" class="btn">INFO</button>
      <button id="btnResetBias" class="btn">RESET_BIAS</button>
      <button id="btnCalMagDisabled" class="btn" disabled>CAL_MAG (N/A)</button>
    </div>

    <div id="telemetry">
      <div class="teleBox" id="quatBox">q: —</div>
      <div class="teleBox" id="eulerBox">Euler: —</div>
      <div class="teleBox">t: <span id="tBox">—</span></div>
      <div class="teleBox">freq: <span id="measFreq">—</span> Hz</div>
    </div>

    <div>
      <div style="margin:6px 0; color:#94a3b8;">Serial Log</div>
      <div id="log"></div>
    </div>

    <div class="footer">Open in Chrome/Edge — serve via <code>localhost</code>. Use the <b>Connect</b> button and pick the Nano's port.</div>
  </div>

  <div id="visual">
    <!-- Three.js canvas will be appended here -->
  </div>

<script type="module">
/* IMU Control Panel — WebSerial + Three.js
   Expects Arduino to output JSON quaternion frames:
     {"q":[x,y,z,w],"t":<micros>}
   where q is [x,y,z,w] (x,y,z vector, w scalar).
*/

import * as THREE from 'https://unpkg.com/three@0.154.0/build/three.module.js';

let port = null;
let reader = null;
let writer = null;
let keepReading = false;
let textDecoder, inputDone , outputDone;
const logEl = document.getElementById('log');
const leftPanel = document.getElementById('left');

const btnConnect = document.getElementById('btnConnect');
const btnDisconnect = document.getElementById('btnDisconnect');
const btnCalGyro = document.getElementById('btnCalGyro');
const btnSave = document.getElementById('btnSave');
const btnLoad = document.getElementById('btnLoad');
const btnInfo = document.getElementById('btnInfo');
const btnResetBias = document.getElementById('btnResetBias');

const inpFreq = document.getElementById('inpFreq');
const srVal = document.getElementById('srVal');
const btnSetFreq = document.getElementById('btnSetFreq');
const freqBox = document.getElementById('freqBox');

const inpBeta = document.getElementById('inpBeta');
const betaVal = document.getElementById('betaVal');
const btnSetBeta = document.getElementById('btnSetBeta');
const betaBox = document.getElementById('betaBox');

const quatBox = document.getElementById('quatBox');
const eulerBox = document.getElementById('eulerBox');
const tBox = document.getElementById('tBox');
const measFreq = document.getElementById('measFreq');
const connectState = document.getElementById('connectState');

let lastJSONTime = 0;
let lastFrameTime = performance.now();
let frameCount = 0;
let measuredHz = 0;

// ---------- Three.js setup ----------
const visual = document.getElementById('visual');
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x071427);
const camera = new THREE.PerspectiveCamera(60, visual.clientWidth / visual.clientHeight, 0.1, 1000);
camera.position.set(2.2, 2.0, 3.5);
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(visual.clientWidth, visual.clientHeight);
visual.appendChild(renderer.domElement);

// responsive
window.addEventListener('resize', () => {
  renderer.setSize(visual.clientWidth, visual.clientHeight);
  camera.aspect = visual.clientWidth / visual.clientHeight;
  camera.updateProjectionMatrix();
});

// Controls: simple orbital via mouse drag
let isPointerDown=false, lastX=0, lastY=0, yaw=0, pitch=-0.4;
renderer.domElement.addEventListener('pointerdown', (e)=>{ isPointerDown=true; lastX=e.clientX; lastY=e.clientY; renderer.domElement.setPointerCapture(e.pointerId); });
renderer.domElement.addEventListener('pointerup', (e)=>{ isPointerDown=false; renderer.domElement.releasePointerCapture(e.pointerId); });
renderer.domElement.addEventListener('pointermove', (e)=>{ if (!isPointerDown) return; let dx=(e.clientX-lastX)/200; let dy=(e.clientY-lastY)/200; yaw += dx; pitch += dy; lastX=e.clientX; lastY=e.clientY; });

// axes helper
const axes = new THREE.AxesHelper(1.5);
scene.add(axes);

// cube
const geo = new THREE.BoxGeometry(1.0, 0.6, 1.6);
const mat = new THREE.MeshStandardMaterial({ color:0x78a1ff, metalness:0.2, roughness:0.35 });
const cube = new THREE.Mesh(geo, mat);
scene.add(cube);

// add coordinate arrows on cube front
const arrowMaterial = new THREE.MeshStandardMaterial({ color:0xff8a65 });
const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.9);
scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 0.8);
dir.position.set(5,5,5);
scene.add(dir);

// small grid floor
const grid = new THREE.GridHelper(8, 16, 0x1b3c44, 0x0b2230);
scene.add(grid);

// Text label: use simple DOM updates (no canvas text)
function animate() {
  requestAnimationFrame(animate);
  // gentle camera orbit from pointer
  camera.position.x = Math.cos(yaw) * 4;
  camera.position.z = Math.sin(yaw) * 4;
  camera.position.y = 2.2 + Math.sin(pitch) * 0.6;
  camera.lookAt(0,0,0);
  renderer.render(scene, camera);
}
animate();

// ---------- Serial helpers ----------
function appendLog(s) {
  const time = new Date().toLocaleTimeString();
  logEl.textContent += `[${time}] ${s}\n`;
  logEl.scrollTop = logEl.scrollHeight;
}

async function connectSerial() {
  try {
    // Request a port and open it
    port = await navigator.serial.requestPort();
    await port.open({ baudRate: 115200 });
    connectState.textContent = 'Connected';
    connectState.style.color = '#86efac';
    btnConnect.disabled = true;
    btnDisconnect.disabled = false;

    // Setup writer
    const textEncoder = new TextEncoderStream();
    outputDone = textEncoder.readable.pipeTo(port.writable)
      .catch(e => { appendLog("output stream pipeTo error: " + e); });
    writer = textEncoder.writable.getWriter();

    // Setup reader
    textDecoder = new TextDecoderStream();
    inputDone = port.readable.pipeTo(textDecoder.writable)
      .catch(e => { appendLog("input stream pipeTo error: " + e); });
    reader = textDecoder.readable
      .pipeThrough(new TransformStream(new LineBreakTransformer()))
      .getReader();

    keepReading = true;
    readLoop(); // start async read loop (don't await here)
    appendLog("Serial connected.");
  } catch (err) {
    appendLog("Connect error: " + err);
    // cleanup partial state
    try { if (writer) { writer.close(); writer = null; } } catch(e){}
    try { if (reader) { reader.cancel(); reader = null; } } catch(e){}
    try { if (port && port.readable) { await port.close(); } } catch(e){}
    port = null;
    btnConnect.disabled = false;
    btnDisconnect.disabled = true;
    connectState.textContent = 'Disconnected';
    connectState.style.color = '#fca5a5';
  }
}

async function disconnectSerial() {
  keepReading = false;
  try {
    if (reader) {
      await reader.cancel();
      reader = null;
    }
  } catch (e) {
    appendLog("Reader cancel error: " + e);
  }
  try {
    if (inputDone) {
      await inputDone.catch(()=>{}); // wait for pipe to finish
      inputDone = null;
    }
  } catch (e) {}

  try {
    if (writer) {
      await writer.close();
      writer = null;
    }
  } catch (e) {
    appendLog("Writer close error: " + e);
  }
  try {
    if (outputDone) {
      await outputDone.catch(()=>{});
      outputDone = null;
    }
  } catch (e) {}

  try {
    if (port) {
      await port.close();
      port = null;
    }
  } catch (e) {
    appendLog("Port close error: " + e);
  }
  connectState.textContent = 'Disconnected';
  connectState.style.color = '#fca5a5';
  btnConnect.disabled = false;
  btnDisconnect.disabled = true;
  appendLog("Serial disconnected.");
}

async function readLoop() {
  if (!reader) return;
  try {
    while (keepReading) {
      const { value, done } = await reader.read();
      if (done) break;
      if (value) handleLine(value);
    }
  } catch (err) {
    appendLog("Read error: " + err);
  } finally {
    // cleanup if loop exits
    keepReading = false;
    if (reader) { try { await reader.cancel(); } catch(e){} reader = null; }
    if (writer) { try { await writer.close(); } catch(e){} writer = null; }
    if (port) { try { await port.close(); } catch(e){} port = null; }
    connectState.textContent = 'Disconnected';
    connectState.style.color = '#fca5a5';
    btnConnect.disabled = false;
    btnDisconnect.disabled = true;
    appendLog("Read loop ended, port closed.");
  }
}


// Send raw text (will append newline)
async function sendCmdLine(line) {
  if (!writer) { appendLog("Not connected"); return; }
  await writer.write(line + "\n");
  appendLog("-> " + line);
}

// Line handler: text stream, lines may be JSON or plain text
let lastQuat = null;
function handleLine(line) {
  line = line.trim();
  if (!line) return;
  // try JSON parse
  try {
    const obj = JSON.parse(line);
    // expect q:[x,y,z,w], t
    if (obj.q && Array.isArray(obj.q) && obj.q.length >= 4) {
      const q = obj.q;
      // Arduino used q=[x,y,z,w] (x,y,z vector, w scalar)
      const x = Number(q[0]), y = Number(q[1]), z = Number(q[2]), w = Number(q[3]);
      applyQuaternion(x,y,z,w);
      quatBox.textContent = `q: [${x.toFixed(6)}, ${y.toFixed(6)}, ${z.toFixed(6)}, ${w.toFixed(6)}]`;
      // compute euler degrees (Three.js helpers)
      const quat = new THREE.Quaternion(x,y,z,w);
      const e = new THREE.Euler().setFromQuaternion(quat, 'ZYX');
      const yaw = THREE.MathUtils.radToDeg(e.z);
      const pitch = THREE.MathUtils.radToDeg(e.y);
      const roll = THREE.MathUtils.radToDeg(e.x);
      eulerBox.textContent = `Yaw:${yaw.toFixed(1)}°  Pitch:${pitch.toFixed(1)}°  Roll:${roll.toFixed(1)}°`;
      if (obj.t) tBox.textContent = obj.t;
      // frequency measure
      frameCount++;
      const now = performance.now();
      if (now - lastFrameTime >= 1000) {
        measuredHz = frameCount * 1000 / (now - lastFrameTime);
        measFreq.textContent = measuredHz.toFixed(1);
        lastFrameTime = now;
        frameCount = 0;
      }
      lastJSONTime = Date.now();
      lastQuat = {x,y,z,w};
      return;
    }
  } catch (e) {
    // not JSON or parse failed, fall through to logging
  }
  // Not JSON — show raw text
  appendLog(line);
}

// apply quaternion to cube (Three.js)
function applyQuaternion(x,y,z,w) {
  // three.js Quaternion is (x,y,z,w)
  cube.quaternion.set(x,y,z,w);
}

// simple line break transformer for streams
class LineBreakTransformer {
  constructor() {
    this.container = "";
  }
  transform(chunk, controller) {
    this.container += chunk;
    const lines = this.container.split(/\r?\n/);
    this.container = lines.pop();
    lines.forEach(line => controller.enqueue(line));
  }
  flush(controller) {
    if (this.container) controller.enqueue(this.container);
  }
}

// ---------- UI Wiring ----------
btnConnect.addEventListener('click', async ()=>{ await connectSerial(); });
btnDisconnect.addEventListener('click', async ()=>{ await disconnectSerial(); });

btnCalGyro.addEventListener('click', ()=> sendCmdLine('CAL_GYRO'));
btnSave.addEventListener('click', ()=> sendCmdLine('SAVE'));
btnLoad.addEventListener('click', ()=> sendCmdLine('LOAD'));

btnInfo.addEventListener('click', ()=> sendCmdLine('INFO'));
btnResetBias.addEventListener('click', ()=> sendCmdLine('RESET_BIAS'));

inpFreq.addEventListener('input', ()=> { srVal.textContent = inpFreq.value; freqBox.value = inpFreq.value; });
btnSetFreq.addEventListener('click', ()=> { const v = freqBox.value; sendCmdLine('SET_FREQ:' + v); inpFreq.value = v; srVal.textContent = v; });

inpBeta.addEventListener('input', ()=> { betaVal.textContent = Number(inpBeta.value).toFixed(3); betaBox.value = Number(inpBeta.value).toFixed(3); });
btnSetBeta.addEventListener('click', ()=> { const v = betaBox.value; sendCmdLine('SET_BETA:' + v); inpBeta.value = v; betaVal.textContent = Number(v).toFixed(3); });

freqBox.addEventListener('change', ()=> { inpFreq.value = freqBox.value; srVal.textContent = freqBox.value; });
betaBox.addEventListener('change', ()=> { inpBeta.value = betaBox.value; betaVal.textContent = Number(betaBox.value).toFixed(3); });

// keyboard shortcuts: C to connect, D to disconnect
window.addEventListener('keydown', (e)=> {
  if (e.key === 'c' || e.key === 'C') btnConnect.click();
  if (e.key === 'd' || e.key === 'D') btnDisconnect.click();
});

// show initial guidance
appendLog("UI ready. Click Connect to pick the Nano's serial port.");

</script>
</body>
</html>
