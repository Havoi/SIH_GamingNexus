<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>IMU Calibrator & Visualizer</title>
    <style>
        body { margin: 0; background: #050505; color: #0f0; font-family: 'Consolas', monospace; overflow: hidden; }
        #hud {
            position: absolute; top: 0; left: 0; padding: 20px;
            background: rgba(0, 0, 0, 0.8); border: 1px solid #333; pointer-events: none;
        }
        #controls {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 10px; z-index: 100; flex-wrap: wrap; justify-content: center; width: 90%;
        }
        button {
            background: #002200; color: #0f0; border: 1px solid #0f0; padding: 15px 20px;
            font-family: inherit; font-size: 14px; cursor: pointer; text-transform: uppercase;
        }
        button:hover { background: #0f0; color: #000; }
        button:disabled { border-color: #555; color: #555; background: #111; cursor: default; }
        .stat { font-size: 12px; opacity: 0.7; margin-top: 5px; }
        #file-input { display: none; } /* Hidden file picker */
    </style>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>
</head>
<body>

<div id="hud">
    <h1>IMU VISUALIZER</h1>
    <div id="status">STATUS: Disconnected</div>
    <div class="stat" id="debug-yaw">Yaw Axis: [PENDING]</div>
    <div class="stat" id="debug-pitch">Pitch Axis: [PENDING]</div>
    <div class="stat" id="debug-out">Output: 0.00, 0.00</div>
</div>

<div id="controls">
    <button id="btn-connect">1. Connect Serial</button>
    <button id="btn-cal-yaw" disabled>2a. Scan Yaw</button>
    <button id="btn-cal-pitch" disabled>2b. Scan Pitch</button>
    
    <button id="btn-import" disabled>3. Import JSON</button>
    <input type="file" id="file-input" accept=".json">

    <button id="btn-recenter" disabled>Recenter (Space)</button>
</div>

<script type="module">
import * as THREE from 'three';

// =========================================================
// 1. ROBUST MATH ENGINE
// =========================================================
class RobustSolver {
    constructor() {
        this.yawAxis = new THREE.Vector3(0, 1, 0);
        this.pitchAxis = new THREE.Vector3(1, 0, 0);
        this.axisSamples = [];
        this.isCalibrating = false;
        
        this.tareQuat = new THREE.Quaternion(); 
        this.currentQuat = new THREE.Quaternion();
        
        this.pitchMultiplier = 1.0; 
        this.yawMultiplier = 1.0; 
        this.sensitivity = 1.0;
    }

    startScan() {
        this.axisSamples = [];
        this.isCalibrating = true;
    }

    stopScanAndGetAxis() {
        this.isCalibrating = false;
        if (this.axisSamples.length === 0) return new THREE.Vector3(0,1,0);
        let mean = new THREE.Vector3(0,0,0);
        for(let v of this.axisSamples) mean.add(v);
        mean.normalize();
        return mean;
    }

    processStream(w, x, y, z) {
        this.currentQuat.set(x, y, z, w).normalize();
    }
    
    sampleCalibrationFrame() {
        if (!this.isCalibrating) return;
        const delta = new THREE.Quaternion().copy(this.tareQuat).invert().multiply(this.currentQuat);
        const theta = 2 * Math.acos(delta.w);
        if (theta > 0.1) { 
            const s = Math.sqrt(1 - delta.w * delta.w);
            if (s > 0.001) {
                const axis = new THREE.Vector3(delta.x/s, delta.y/s, delta.z/s);
                if (this.axisSamples.length > 0 && axis.dot(this.axisSamples[0]) < 0) axis.negate();
                this.axisSamples.push(axis);
            }
        }
    }

    setAxes(yaw, pitch) {
        this.yawAxis.copy(yaw).normalize();
        this.pitchAxis.copy(pitch).normalize();
    }
    
    recenter() {
        this.tareQuat.copy(this.currentQuat);
    }

    getAngles() {
        const delta = new THREE.Quaternion().copy(this.tareQuat).invert().multiply(this.currentQuat);
        const w = Math.max(-1, Math.min(1, delta.w));
        const angle = 2 * Math.acos(w);
        if (Math.abs(angle) < 0.001) return { yaw: 0, pitch: 0 };
        const s = Math.sqrt(1 - w*w);
        let axis = new THREE.Vector3(delta.x, delta.y, delta.z).divideScalar(s);
        
        const yawContribution = axis.dot(this.yawAxis);
        const pitchContribution = axis.dot(this.pitchAxis);
        
        return {
            yaw: angle * yawContribution * this.yawMultiplier,
            pitch: angle * pitchContribution * this.pitchMultiplier
        };
    }

    // NEW: Load JSON Profile directly
    loadProfile(json) {
        this.yawAxis.set(json.yawAxis.x, json.yawAxis.y, json.yawAxis.z);
        this.pitchAxis.set(json.pitchAxis.x, json.pitchAxis.y, json.pitchAxis.z);
        this.yawMultiplier = json.yawMultiplier;
        this.pitchMultiplier = json.pitchMultiplier;
        console.log("Profile Loaded:", this.yawAxis, this.pitchAxis);
    }
}

const solver = new RobustSolver();

// =========================================================
// 2. THREE.JS VISUALIZATION
// =========================================================
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x050505);
scene.fog = new THREE.FogExp2(0x050505, 0.02);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const grid = new THREE.GridHelper(50, 50, 0x00ff00, 0x003300);
scene.add(grid);

const cursorGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
const cursorMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
const cursor = new THREE.Mesh(cursorGeo, cursorMat);
cursor.position.set(0, 0, -5);
scene.add(cursor);

// =========================================================
// 3. UI & LOGIC
// =========================================================
let port, reader, keepReading = false;
let capturedYawAxis = null;
let capturedPitchAxis = null;
let controlActive = false;

// CONNECT
document.getElementById('btn-connect').onclick = async () => {
    try {
        port = await navigator.serial.requestPort();
        await port.open({ baudRate: 115200 });
        keepReading = true;
        readLoop();
        document.getElementById('status').innerText = "STATUS: CONNECTED";
        document.getElementById('btn-connect').disabled = true;
        document.getElementById('btn-cal-yaw').disabled = false;
        document.getElementById('btn-import').disabled = false; // Enable import
    } catch(e) { alert(e); }
};

// IMPORT JSON HANDLER
const btnImport = document.getElementById('btn-import');
const fileInput = document.getElementById('file-input');

btnImport.onclick = () => fileInput.click();

fileInput.onchange = (e) => {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (event) => {
        try {
            const json = JSON.parse(event.target.result);
            solver.loadProfile(json);
            
            // Update UI to show we are live
            document.getElementById('debug-yaw').innerText = "Yaw Axis: [LOADED FROM FILE]";
            document.getElementById('debug-pitch').innerText = "Pitch Axis: [LOADED FROM FILE]";
            document.getElementById('status').innerText = "STATUS: PROFILE LOADED - ACTIVE";
            
            // Enable controls
            controlActive = true;
            document.getElementById('btn-recenter').disabled = false;
            createExtraButtons(); // Add Save/Invert buttons
            
            // Disable Calibration buttons to avoid confusion
            document.getElementById('btn-cal-yaw').disabled = true;
            document.getElementById('btn-cal-pitch').disabled = true;
            btnImport.innerText = "PROFILE LOADED";
            
        } catch (err) {
            alert("Invalid JSON File");
        }
    };
    reader.readAsText(file);
};

// MANUAL YAW CALIBRATION
const btnYaw = document.getElementById('btn-cal-yaw');
btnYaw.onclick = () => {
    if (!solver.isCalibrating) {
        solver.recenter(); 
        solver.startScan();
        btnYaw.innerText = "Scanning... Rotate Left/Right";
        btnYaw.style.background = "#990000";
    } else {
        capturedYawAxis = solver.stopScanAndGetAxis();
        document.getElementById('debug-yaw').innerText = `Yaw Axis: Found`;
        btnYaw.innerText = "Yaw Done";
        btnYaw.disabled = true;
        btnYaw.style.background = "";
        document.getElementById('btn-cal-pitch').disabled = false;
    }
};

// MANUAL PITCH CALIBRATION
const btnPitch = document.getElementById('btn-cal-pitch');
btnPitch.onclick = () => {
    if (!solver.isCalibrating) {
        solver.recenter();
        solver.startScan();
        btnPitch.innerText = "Scanning... Rotate Up/Down";
        btnPitch.style.background = "#990000";
    } else {
        capturedPitchAxis = solver.stopScanAndGetAxis();
        document.getElementById('debug-pitch').innerText = `Pitch Axis: Found`;
        solver.setAxes(capturedYawAxis, capturedPitchAxis);
        
        btnPitch.innerText = "Pitch Done";
        btnPitch.disabled = true;
        btnPitch.style.background = "";
        document.getElementById('btn-recenter').disabled = false;
        
        controlActive = true;
        createExtraButtons();
        document.getElementById('status').innerText = "STATUS: CONTROL ACTIVE";
    }
};

document.getElementById('btn-recenter').onclick = () => {
    solver.recenter();
};

window.addEventListener('keydown', (e) => {
    if (e.code === 'Space') solver.recenter();
});

function createExtraButtons() {
    const container = document.getElementById('controls');
    
    // Check if buttons already exist to prevent duplicates
    if(document.getElementById('btn-save')) return;

    const invPitchBtn = document.createElement('button');
    invPitchBtn.innerText = "Inv Pitch";
    invPitchBtn.onclick = () => { solver.pitchMultiplier *= -1; };
    container.appendChild(invPitchBtn);

    const invYawBtn = document.createElement('button');
    invYawBtn.innerText = "Inv Yaw";
    invYawBtn.style.marginLeft = "10px";
    invYawBtn.onclick = () => { solver.yawMultiplier *= -1; };
    container.appendChild(invYawBtn);
    
    const saveBtn = document.createElement('button');
    saveBtn.id = 'btn-save';
    saveBtn.innerText = "SAVE JSON";
    saveBtn.style.background = "#004400";
    saveBtn.style.marginLeft = "10px";
    saveBtn.onclick = () => {
        const profile = {
            yawAxis: solver.yawAxis,
            pitchAxis: solver.pitchAxis,
            yawMultiplier: solver.yawMultiplier,
            pitchMultiplier: solver.pitchMultiplier
        };
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(profile));
        const dlAnchor = document.createElement('a');
        dlAnchor.setAttribute("href", dataStr);
        dlAnchor.setAttribute("download", "imu_calibration.json");
        dlAnchor.click();
    };
    container.appendChild(saveBtn);
}

// =========================================================
// 4. ANIMATION LOOP
// =========================================================
function animate() {
    requestAnimationFrame(animate);

    if (solver.isCalibrating) {
        solver.sampleCalibrationFrame();
    }
    
    if (controlActive && !solver.isCalibrating) {
        const angles = solver.getAngles();
        document.getElementById('debug-out').innerText = `Yaw: ${(angles.yaw*57).toFixed(1)} | Pitch: ${(angles.pitch*57).toFixed(1)}`;

        const targetQ = new THREE.Quaternion();
        targetQ.setFromEuler(new THREE.Euler(-angles.pitch, -angles.yaw, 0, 'YXZ'));
        camera.quaternion.slerp(targetQ, 0.5);
    }
    
    renderer.render(scene, camera);
}
animate();

// =========================================================
// 5. SERIAL READER
// =========================================================
async function readLoop() {
    const textDecoder = new TextDecoderStream();
    port.readable.pipeTo(textDecoder.writable);
    const reader = textDecoder.readable.getReader();
    let buffer = "";

    while (keepReading) {
        const { value, done } = await reader.read();
        if (done) break;
        buffer += value;
        const lines = buffer.split('\n');
        buffer = lines.pop();
        for (const line of lines) {
            try {
                const json = JSON.parse(line);
                if (json.type === "imu" && json.quat) {
                    solver.processStream(json.quat[0], json.quat[1], json.quat[2], json.quat[3]);
                }
            } catch(e) {}
        }
    }
}

window.onresize = () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
};
</script>
</body>
</html>